#!/usr/bin/perl

use Digest::SHA;
use File::Basename;
use File::Spec;

use strict;

my $DESCRIPTOR_FILENAME = "00descriptor.gfs";

local $main::run_files_fullread = 0;
local $main::run_descriptors_read = 0;

sub main()
{
	print "Welcome to Ghost.\n";

	my $verb = shift @ARGV;

	print " Verb = [$verb]\n";

	if( $verb eq "info" )
	{
		doverb_info();
	}


	# LS tells us what we can find out about the current directory tree
	# nothing is force read, only stat'ed

	if( $verb eq "ls" )
	{
		doverb_ls();
	}

	# Basically a test verb used to prove that serialization and deserialization are identical

	if( $verb eq "copyDescriptor" )
	{
		my $src = shift @ARGV;
		my $d = shift @ARGV;

		my $store = GhostStore->new();
		$store->slurpDescriptor( $src);
		$store->writeAsDescriptor( $d );
	}

	print "Full reads: $main::run_files_fullread\n"

}


sub getGhostDescriptorFileForLFN($)
{
	my $filename = shift;

	my( $fn, $dir ) = fileparse( $filename );

 	my $dfn = File::Spec->catfile($dir, $DESCRIPTOR_FILENAME);

	return $dfn;
}

sub doverb_ls()
{
	my $store = GhostStore->new();

	foreach my $lfn (@ARGV)
	{
		my $dfn = getGhostDescriptorFileForLFN($lfn);

		print "Pulling in any descriptor for [$lfn] -> [$dfn]\n";



		# First look for a ghost from the descriptor file
		# call getGhostDescriptorFileForLFN()
		# if there is a desccriptor, load it

		# we have a ghostStore gs
		# slurp all of the descriptors into the gs object
		# the interate over the the files and print out what we know

		# slurping means we need to de-duplicate

	}

}


sub doverb_info()
{

	my $store = GhostStore->new();
	$store->slurpDescriptor( "GhostDescriptors" );

	foreach my $lfn (@ARGV)
	{
		print( "Info request for: $lfn\n");
		my $g = Ghost->make( $lfn );
		my $h = $g->getFullHash();
		print("    $h\n");

		$store->addGhost( $g );
	}	

	$store->writeAsDescriptor( "GhostDescriptors" );


}



sub getFullHash($)
{
	## TODO - implement without full slurp

	my $lfn = shift;

	my $sha = Digest::SHA->new(1);
	$sha->addfile( $lfn );
	my $hexdigest = $sha->hexdigest();

	$main::run_files_fullread++;

	return( "SHA1/FULL/$hexdigest");

}


package GhostStore;

use base qw(Class::Accessor);
GhostStore->mk_accessors( qw(ghosts) );

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();
	$self->ghosts( +[] );

	return $self;
}

sub addGhost($)
{
	my $self= shift;
	my $g = shift;

	my $ghosts = $self->ghosts();

	# Do the incorporation here


	push @$ghosts, $g;
}

sub slurpDescriptor($)
{
	my $self = shift;
	my $fn = shift;

	my $ghosts = $self->ghosts();

	open( FILE, "<$fn") or die "Cannot open $fn to read descriptor";

	while( <FILE> )
	{
		chomp;
		print "Slurping: $_\n";
		my $g = Ghost->newFromSerialized( $_ );
		$self->addGhost( $g );
	}

	close( FILE );
}


sub writeAsDescriptor($)
{
	my $self = shift;
	my $fn = shift;

	my $ghosts = $self->ghosts();

	open( FILE, ">$fn") or die "Cannot open $fn to write descriptor";

	foreach my $g ( @$ghosts )
	{
	
		print FILE $g->serialize();
		print FILE "\n";
	}

	close( FILE );
}


package Ghost;

use base qw(Class::Accessor);
Ghost->mk_accessors( qw(lfn lastFullHash fullHash ) );

sub newFromSerialized($)
{
	my $class = shift;
	my $str = shift;

	my $self = Ghost->new();

	my @a = split ':', $str;

	$self->lfn( shift @a );
	$self->lastFullHash( shift @a );
	$self->fullHash( shift @a );

	return $self;

}

sub serialize()
{
	my $self = shift;

	my @s = ( $self->lfn(), 
			  $self->lastFullHash(),
			  $self->fullHash()
			  );

	my $s = join ':', @s;

	return $s;
}

sub make($)
{
	my $class = shift;
	my $lfn = shift;

	my $self = $class->new();

	print "Making Ghost for lfn=[$lfn]\n";
	$self->lfn( $lfn );
	return $self;
}


sub getFullHash
{
	my $self = shift;
	my $lfn = $self->lfn();

	$self->lastFullHash( time() );


 	my $fullhash = main::getFullHash( $lfn );

	$self->fullHash( $fullhash );

	return $fullhash;
}


###

main::main();
exit();



