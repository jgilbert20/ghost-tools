#!/usr/bin/perl

use Digest::SHA;
use File::Basename;
use File::Spec;

use strict;

my $DESCRIPTOR_FILENAME = "00descriptor.gfs";

local $main::run_files_fullread = 0;
local $main::run_descriptors_read = 0;

sub main()
{
	print "Welcome to Ghost.\n";

	my $verb = shift @ARGV;

	print " Verb = [$verb]\n";

	if( $verb eq "info" )
	{
		doverb_info();
	}

	# LS tells us what we can find out about the current directory tree
	# nothing is force read, only stat'ed

	if( $verb eq "ls" )
	{
		doverb_ls();
	}


	# Takes the listed things and writes a single descriptor file

	if( $verb eq "write-descriptor")
	{
		doverb_writeDescriptor();
	}

	# Basically a test verb used to prove that serialization and deserialization are identical

	if( $verb eq "copyDescriptor" )
	{
		my $src = shift @ARGV;
		my $d = shift @ARGV;

		my $store = GhostStore->new();
		$store->slurpDescriptor( $src);
		$store->writeAsDescriptor( $d );
	}

	print "Full reads: $main::run_files_fullread\n";
	flushGhostDescriptorCache();


}


sub getGhostDescriptorFileForLFN($)
{
	my $filename = shift;

	my( $fn, $dir ) = fileparse( $filename );

 	my $dfn = File::Spec->catfile($dir, $DESCRIPTOR_FILENAME);

	return $dfn;
}

sub doverb_ls()
{
	my $store = GhostStore->new();

	foreach my $lfn (@ARGV)
	{
		my $dfn = getGhostDescriptorFileForLFN($lfn);

		print "Pulling in any descriptor for [$lfn] -> [$dfn]\n";

		$store->slurpDescriptor( $lfn );

		# First look for a ghost from the descriptor file
		# call getGhostDescriptorFileForLFN()
		# if there is a desccriptor, load it

		# we have a ghostStore gs
		# slurp all of the descriptors into the gs object
		# the interate over the the files and print out what we know

		# slurping means we need to de-duplicate

	}

}


sub doverb_writeDescriptor()
{
	my $store = GhostStore->new();

	my $fse = new FilesystemExplorer();
	$fse->setRoots( @ARGV );

	while( defined( my $file = $fse->next() ) )
	{
		print "Scanned $file\n";

		my $fullHash = $fse->getFullHash( $file );

		print "WriteDescriptor: fullhash = $fullHash\n";
	}
}

sub doverb_info()
{
	my $store = GhostStore->new();
	$store->slurpDescriptor( $DESCRIPTOR_FILENAME  );

	foreach my $lfn (@ARGV)
	{
		print( "Info request for: $lfn\n");
		my $g = Ghost->make( $lfn );
		my $h = $g->getFullHashForceHitDisk();
		print("    $h\n");

		$store->addGhost( $g );
	}	

	$store->writeAsDescriptor( $DESCRIPTOR_FILENAME );
}



sub getFullHashForceHitDisk($)
{
	## TODO - implement without full slurp

	my $lfn = shift;

	my $sha = Digest::SHA->new(1);
	$sha->addfile( $lfn );
	my $hexdigest = $sha->hexdigest();

	$main::run_files_fullread++;

	return( "SHA1/FULL/$hexdigest");

}

my %ghostStoreForDescriptorLFN;

sub flushGhostStoreLFNCacheEntry
{
	my $lfn = shift;

	print "Flushing ghoststore [$lfn] to disk\n";

	if( not exists $ghostStoreForDescriptorLFN{$lfn} )
	{
		die "Internal assert - $lfn not found";
	}

	my $gs = $ghostStoreForDescriptorLFN{$lfn};

	if( $gs->clean() )
	{
		print "   -- clean flag set\n";
	}
	else
	{
		print "   -- clean flag not set, write needed\n";
		$gs->writeAsDescriptor( $DESCRIPTOR_FILENAME );

	}	

	delete $ghostStoreForDescriptorLFN{$lfn};

	return undef; 
}

sub flushGhostDescriptorCache
{
	foreach my $lfn (keys %ghostStoreForDescriptorLFN )
	{
		flushGhostStoreLFNCacheEntry( $lfn );

	}
}

sub getGhostStoreForDescriptorFileCoveringFN
{
	my $lfn = shift;

	my $gsfn = getGhostDescriptorFileForLFN( $lfn );

	if( exists $ghostStoreForDescriptorLFN{$gsfn} )
	{
		return( $ghostStoreForDescriptorLFN{$gsfn} );
	}
	else
	{
		die "Overflow!" if ((keys %ghostStoreForDescriptorLFN) > 10);

		my $gs = GhostStore->new();

		if( -e $gsfn )
		{
			$gs->slurpDescriptor( $DESCRIPTOR_FILENAME );
		}

		$ghostStoreForDescriptorLFN{$gsfn} = $gs;

		return $gs;

	}

}


package FilesystemExplorer;

use base qw(Class::Accessor);
FilesystemExplorer->mk_accessors( qw(topLevelLFNs queue) );

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();

	return $self;
}

# Caller wants the full hash
# Best place to get it is a descriptor file
# next best place to get it is to hit the disk

sub getFullHash()
{
	my $self = shift;
	my $lfn = shift;

	# TODO error check that this path actual existing in the FSE!

	my $gs = main::getGhostStoreForDescriptorFileCoveringFN($lfn);

	print "Searching hash for [$lfn]\n";

	my $g = $gs->findOrMakeGhostByLFN($lfn);

	my $h = $g->getFullHash();

	return $h;
}

sub setRoots()
{
	my $self = shift;

	$self->topLevelLFNs( [@_] );
	$self->queue( [@_] );
}

sub scanDir
{
	my $self = shift;
	my $dir = shift;

	my $q = $self->queue();	

	#print "Scanning into $dir\n";

	opendir DIR, $dir;

	# drop . and .., sort directory
	my @files = map { $dir.'/'.$_ } grep { !/^\.{1,2}$/ } sort { $a cmp $b } readdir DIR;

	# print( "Got: ", (join ':', @files ), "\n" );

	close DIR;

	unshift @$q, \$dir;
	unshift @$q, @files;
	
}


# returns the next directory

sub next
{
	my $self = shift;

	my $n = $self->nextRaw();

	if( ref $n )
	{
		print "THUNK received --> $$n\n";

		# TODO case: 
		# in this case, we have just exited a directory -- may want
		# to purge any contents of descriptors that weren't found

		return $self->next();
	}

	return $n;
}


sub nextRaw
{
	my $self = shift;

	my $q = $self->queue();

	my $c = shift @$q;

	if( not defined $c )
	{
		return undef; 
	}

	# print "Got[$c]\n";

	# if the next thing is a directory, scan into the directory
	if( -d $c )
	{
		$self->scanDir( $c );
	}

	return $c;
}



package GhostStore;

use base qw(Class::Accessor);
GhostStore->mk_accessors( qw(lfnToGhost clean) );

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();
	$self->lfnToGhost( +{} );
	$self->clean(1);

	return $self;
}

sub findOrMakeGhostByLFN
{
	my $self = shift;
	my $lfn = shift;

	my $lfnToGhost = $self->lfnToGhost();


	print "Looking for ghost [$lfn]\n";

	if( exists $lfnToGhost->{$lfn} )
	{
		print "   Found inside ghoststore\n";
		return  $lfnToGhost->{$lfn};
	}
	else
	{

		print( "   Making new ghost for $lfn\n");
		my $g = Ghost->make( $lfn );

		$self->addGhost( $g );
		return $g;
	}



}

sub addGhost($)
{
	my $self= shift;
	my $g = shift;

	my $lfnToGhost = $self->lfnToGhost();

	# Do the incorporation here
	# the major caching form is by localname which is assumed to be unique
	# there should only be one ghost per LFN

	if( exists $lfnToGhost->{$g->lfn()} )
	{
		# merge case
		# take the best of both
		# prefer checksum from the newer one
		# use that for the date of the hash

		my $base = $lfnToGhost->{$g->lfn()};

		if( $base->lastFullHash() < $g->lastFullHash() )
		{
			$base->lastFullHash( $g->lastFullHash() );
			$base->fullHash( $g->fullHash() );

			print "  -  Merger case - old wins";
		}
		else
		{
			print "  -  Merger case - new wins";
		}
	}
	else
	{
		$lfnToGhost->{$g->lfn()} = $g; 
	}

	$self->clean(0);

	return;
}

sub slurpDescriptor($)
{
	my $self = shift;
	my $fn = shift;

	open( FILE, "<$fn") or die "Cannot open $fn to read descriptor";

	while( <FILE> )
	{
		chomp;
		print "Slurping: $_\n";
		my $g = Ghost->newFromSerialized( $_ );
		$self->addGhost( $g );
	}

	close( FILE );

	$self->clean(1);
}


sub writeAsDescriptor($)
{
	my $self = shift;
	my $fn = shift;


	my $lfnToGhost = $self->lfnToGhost();


	open( FILE, ">$fn") or die "Cannot open $fn to write descriptor";

	foreach my $g ( values %$lfnToGhost )
	{
	
		print FILE $g->serialize();
		print FILE "\n";
	}

	close( FILE );

	$self->clean(1);
}


package Ghost;

use base qw(Class::Accessor);
Ghost->mk_accessors( qw(lfn lastFullHash fullHash ) );

sub newFromSerialized($)
{
	my $class = shift;
	my $str = shift;

	my $self = Ghost->new();

	my @a = split ':', $str;

	$self->lfn( shift @a );
	$self->lastFullHash( shift @a );
	$self->fullHash( shift @a );

	return $self;

}

sub serialize()
{
	my $self = shift;

	# TODO: Add proper escapes (String::Escape has nice examples)

	my @s = ( $self->lfn(), 
			  $self->lastFullHash(),
			  $self->fullHash()
			  );

	my $s = join ':', @s;

	return $s;
}

sub make($)
{
	my $class = shift;
	my $lfn = shift;

	my $self = $class->new();

	print "Making ghost for lfn=[$lfn]\n";
	$self->lfn( $lfn );
	return $self;
}

# Normally, the latest cached data is trusted, but
# this function can be set to take a out of data criteria in future TODO

sub getFullHash
{
	my $self = shift;

	if( defined $self->fullHash() )
	{
		return $self->fullHash();
	}
	else
	{
		return $self->getFullHashForceHitDisk();
	}
}


sub getFullHashForceHitDisk
{
	my $self = shift;
	my $lfn = $self->lfn();

	$self->lastFullHash( time() );

 	my $fullhash = main::getFullHashForceHitDisk( $lfn );

	$self->fullHash( $fullhash );

	return $fullhash;
}


###

main::main();
exit();



