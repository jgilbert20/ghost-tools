#!/usr/bin/perl

use strict;
use warnings;
use diagnostics;
use diagnostics -verbose;

use Digest::SHA;
use File::Basename;
use File::Spec;
use File::Path;
use File::Copy; 
use Time::HiRes qw( CLOCK_REALTIME gettimeofday tv_interval);
use Getopt::Long;
use POSIX; # needed for time formating
use Cwd qw(abs_path); # best way to get absolute paths
use Data::Dumper;

# Database Layer

use BerkeleyDB;
use BerkeleyDB::Hash;
use BerkeleyDB::Btree;

# Gives us tied access to databases

use MLDBM qw( BerkeleyDB::Hash Storable );

# Key function prototypes

sub debug($);

local $main::SCRIPT_START = time();
local $main::SCRIPT_START_GTOD = [gettimeofday];

# These parameters control our acceptable "out of dateness". If undefined,
# than any available cached data is used. These variables alone do not fully
# influence how changes are directed. For instance, a changed size() ALWAYS
# revokes the hash. But a changed modification date does not trigger a re-
# hash.

local $main::GUARD_TIME_SECONDS_STAT = 10; 
local $main::GUARD_TIME_SECONDS_ENUMERATION = undef; 
local $main::GUARD_TIME_SECONDS_FULLHASH = undef; 
local $main::GUARD_TIME_SECONDS_DEEPSCAN = undef; 

# Debug control

my $ioDebug             = 1;   # Print stats, reads, readdirs, etc. 
my $staleInfoDebug      = 0;   # Decisionmaking on if data is current enough
my $icDebug             = 0;   # TK incorporation
my $tkdebug             = 0;   # TK general
my $tkflushdebug        = 0;   # End of script TK flushes
my $gsDebug             = 0;   # Ghost store debug
my $gdbDebug            = 0;   # GhostDirectory
my $duplicateDebug      = 0;   # Duplicate checking debugging
my $granularSerialDebug = 0;   # Instruments the escape/unescape mechanism
my $serializeDebug      = 0;   # Instruments the load/save at ghost level
my $gChildDebug         = 0;
my $fseDebug            = 0;
my $fseOjxDebug         = 0;
my $fseSnapshotDebug    = 0;
my $learnDebug          = 0;
my $revokeDebug         = 0;   # Special case of learn that just looks at hash revocation
my $statStructDebug     = 0;
my $provenanceDebug     = 1;

# Constant Symbols 

my $ZERO_LEN_FILE = [];
my $CODE_SKIP_DUPLICATE = [];


# Major globals

my $PATH_DEFAULT_OBJECT_STORE = '__gfs_ojx/test';
my $DIRTYLOGFN                = '__gfslog';
my $PATH_DEFAULT_DB_DIR       = "__gfs_dbd";
my $DESCRIPTOR_FILENAME       = ".gfs_ip";
my $SERIALIZATION_VERSION_NUMBER = 5;
my $GENERAL_DEBUG = 1;
my $USUAL_IGNORE = 1;
my $DEBUG_INDENT = 0;

my %debugDump; 

# Run statistics - globals

local $main::run_files_fullread = 0;
local $main::run_bytes_fullread = 0;
local $main::run_time_fullread = 0;
local $main::run_files_stat = 0;
local $main::run_descriptors_read = 0;
local $main::run_descriptors_write = 0;
local $main::readdir_invokes = 0;
local $main::readdir_entries = 0;
local $main::run_files_copied = 0;
local $main::run_bytes_copied = 0;
local $main::run_files_moved = 0;
local $main::run_db_puts = 0;
local $main::run_db_gets = 0;

# Codepatch tracking

my %codepathCount;

# Get path to our WD

my $HOME  = $ENV{HOME};
my $WDIR  = "$HOME/.gfs";
my $DBDIR = "$WDIR/db";
my $EDIR  = "$ENV{HOME}/.gfsrun/EXEC-$$";

# These are the two "global" FSE objects used to resolve fs: and obj: LFNs

$main::localFileSystemFSE = undef;
$main::coreOjxFSE = undef; 

# The global database used everwhere

$main::coreGhostDatabase = undef; 

# Option management

my $OPT_ALL = 0;
my $OPT_STATS = 0;
my $OPT_CP = 0;
my $OPT_DEBUG_DUMP = 0;
my $OPT_CHDIR = undef;
my $OPT_GUARDTIME = undef;

&GetOptions( 'all' => \$OPT_ALL,
			 'G|guard=s' => \$OPT_GUARDTIME,
			 'C|cp' => \$OPT_CP,
			 'chdir=s' => \$OPT_CHDIR,
			 'debug-dump' => \$OPT_DEBUG_DUMP,q
			 'stats' => \$OPT_STATS );


if( defined $OPT_GUARDTIME )
{
	$main::GUARD_TIME_SECONDS_STAT        = $OPT_GUARDTIME;
	$main::GUARD_TIME_SECONDS_ENUMERATION = $OPT_GUARDTIME;
	$main::GUARD_TIME_SECONDS_FULLHASH    = $OPT_GUARDTIME;
#	debug "Guard time set to: $main::GUARD_TIME_SECONDS_\n";
}

if( defined $OPT_CHDIR )
{
	debug( "Changing to [$OPT_CHDIR]" );
	die "Attempted chdir to dir:[$OPT_CHDIR] that doesn't exist" unless -e $OPT_CHDIR;
	chdir $OPT_CHDIR;
}


# Utility function to present relative time in a human readable way

sub expressRelativeTime
{
	my $seconds = shift;

	if( $seconds > 24*60*60)
	{
		$seconds /= 24*60*60;
		my $r = sprintf( "%0.4s days", $seconds );
		return $r;
	}

	if( $seconds > 2*60*60)
	{
		$seconds /= 60*60;
		my $r = sprintf( "%0.4s hours", $seconds );
		return $r;
	}

	if( $seconds > 120)
	{
		$seconds /= 60;
		my $r = sprintf( "%0.4s min", $seconds );
		return $r;
	}

	return "$seconds" . "s";
}



sub debugLevel
{
	my $v = shift;

	$DEBUG_INDENT += $v;

}


# Helper function that creates a nested path with lots of error checking

sub mkdirs
{
    my $dir = shift;
    my $dirx = dirname $dir;

    # debug "MKDIRS:[$dirx]\n";
    eval{ mkpath($dirx,1) };
    $@ and die "Couldn't create dir path: $@";
    die "Did not find new path" if not -d $dirx;

   return 1;
}

# Helper function - if user requests it, ignores shit things like .git and
# .DS_Store. Returns true if the file is good to go, or false if it is usually
# ignored This is not to be used for avoiding actual logic or recursion errors
# (such as scanning our own descriptors). User should be free to turn this
# feature off and the program must work as intended.
#
# This feature is especially important when tracking files that contribute to
# directory hashes. .DS_Store files can change at VERY random times, either
# due to dropbox or some other process I'm not aware of. 

sub fileIsUsuallyIgnored
{
	my $cfn = shift;

	return 0 if( not $USUAL_IGNORE );

	return 1 if $cfn =~ /\.DS_Store$/;
	return 1 if $cfn =~ /Thumbs.db$/;
	return 1 if $cfn =~ /\.pcip_info$/;

	return 0;
}

# Verifies readability of various directories needed for program invocation

sub verifyWorkingDirectories
{
	if( not -e $WDIR )
	{
	    mkdir $WDIR or die "Error creating [$WDIR]: $!";
	}

	if( not -e $DBDIR )
	{
	    mkdir $DBDIR or die "Error creating [$DBDIR]: $!";
	}

	if( not -e $EDIR )
	{
	    mkdirs($EDIR . "/") or die "Error creating [$EDIR]: $!";
	}

	die "Cannot create $WDIR" unless -w $WDIR;
	die "Cannot create $DBDIR" unless -w $DBDIR;
}

# Sets up our data

sub setupDatabases
{
	my $gdb = GhostDatabase->new( $PATH_DEFAULT_DB_DIR );
	$gdb->init();
	$main::coreGhostDatabase = $gdb;
}

sub debug ($)
{
	return if not $GENERAL_DEBUG;
	my $a = shift @_;
	chomp $a;
	print STDERR (("     " x $DEBUG_INDENT ). "D:" . $a . "\n");
}


sub CODEPATH($)
{	
	my $p = shift; 
	$codepathCount{$p}++;
	print( "CODEPATH: $p\n" ) if $OPT_CP;
}

sub reportCodepaths
{
	return if( not keys %codepathCount > 0 );
	return if not $OPT_CP;

	print "--\n";
	print "Codepaths:\n";

	foreach my $p (sort keys %codepathCount )
	{
		print "$codepathCount{$p}\t$p\n";
	}
}

sub handleDebugDump
{
	my $self = shift;

	return unless $OPT_DEBUG_DUMP;

	$debugDump{codepaths} = \%codepathCount;
	$debugDump{stats} = 
	{
		run_files_fullread     =>      $main::run_files_fullread,
		run_bytes_fullread     =>      $main::run_bytes_fullread,
		run_time_fullread      =>       $main::run_time_fullread,
		run_files_stat         =>          $main::run_files_stat,
		run_descriptors_read   =>    $main::run_descriptors_read,
		run_descriptors_write  =>   $main::run_descriptors_write,
		readdir_invokes        =>         $main::readdir_invokes,
		readdir_entries        =>         $main::readdir_entries,
		run_files_copied       =>        $main::run_files_copied,
		run_bytes_copied       =>        $main::run_bytes_copied,
		run_files_moved        =>         $main::run_files_moved,
		run_db_puts            =>             $main::run_db_puts,
		run_db_gets            =>             $main::run_db_gets,
	};

	open DEBUG, ">/tmp/gfsLast.dump" or die "Cannot open file for data dumping";
	print DEBUG Dumper( \%debugDump );
	print STDERR Dumper( \%debugDump );
	close DEBUG;
}


sub init
{
	verifyWorkingDirectories();
	setupDatabases();

	# Set up default file system management object
	$main::localFileSystemFSE = new FilesystemExplorer::FS();

	# Set up object store
	my $ojx = FilesystemExplorer::ObjectStore->new( $PATH_DEFAULT_OBJECT_STORE );
	$ojx->setUpRepository();
	$main::coreOjxFSE = $ojx; 
}

sub gfs_escape($)
{
	my $v = shift;

	return "_" if not defined $v;

	$v =~ s/\:/\\c/gs;
	$v =~ s/\@/\\a/gs;
	$v =~ s/\#/\\p/gs;
	$v =~ s/\n/\\n/gs;
	$v =~ s/\_/\\l/gs;

	$v =~ s/([^\x20\x21\x24\x25-\x39\x41-\x5b\x5d-\x7e])/"\\x(" . unpack('H2', $1) . ")" /gse;

	return $v;
}

sub gfs_unescape($)
{
	my $v = shift;

	return undef if( $v eq "_");

	$v =~ s/\\x\(([\da-fA-F]+)\)/ pack('H2', $1) /gse;

	$v =~ s/\\c/:/gs;
	$v =~ s/\\a/\@/gs;
	$v =~ s/\\p/\#/gs;
	$v =~ s/\\n/\n/gs;
	$v =~ s/\\l/\_/gs;

	return $v;
}

sub main()
{
	# print "Welcome to Ghost.\n";

	init();

	# TODO: Some kind of sanity checking on arguments
	# Are all the files listed MECE?
	# Just a warning is fine here but the user ought to be prompted
	# just to be sure

	my $tk = TruthKeeper::get();

	my $verb = shift @ARGV;

	handleVerb( $verb );

	print "------------ MAIN ACTION COMPlETE ------------\n\n";

	FSEFactory->shutdown();

	$tk->flush();

	if( $OPT_STATS )
	{
		handleStats();
	}

	reportCodepaths();
	handleDebugDump();
}


sub handleStats
{
	print "----- DONE -----\n";

	print "Full reads count: $main::run_files_fullread\n";
	print "Full reads size : $main::run_bytes_fullread\n";
	print "Full read time  : $main::run_time_fullread\n";

	print "Stat reads      : $main::run_files_stat\n";

	print "Local .gfs reads: $main::run_descriptors_read\n";
	print "Local .gfs writs: $main::run_descriptors_write\n";
	print "Readdir invokes : $main::readdir_invokes\n";
	print "Readdir entries : $main::readdir_entries\n";

	print "Files copied    : $main::run_files_copied\n";
	print "Bytes copied    : $main::run_bytes_copied\n";
	print "Files moved     : $main::run_files_moved\n";

	print "Database puts   : $main::run_db_puts\n";
	print "Database gets   : $main::run_db_gets\n";

	print "Total Script Time: " . tv_interval( $main::SCRIPT_START_GTOD ) . "\n";	
}

sub handleVerb
{
	my $verb = shift;

	die "No verb defined" if not defined $verb;

	if( $verb eq "debug")
	{
		doverb_debug();
		return;
	}
	if( $verb eq "test")
	{
		doverb_test();
		return;
	}
	if( $verb eq "lsdup")
	{
		doverb_lsdup();
		return;
	}
	if( $verb eq "help")
	{
		doverb_help();
		return;
	}


	# Interface into the pointer storage and retrieval system

	if( $verb eq "pointer" )
	{
		doverb_pointer();
		return;
	}

	# The "store" verb basically pushes the contents to the location specified
	# typically as a copy operation. Originally intended to store files into
	# the OJX. (Full semantics have not been worked out.)

	if( $verb eq "store" )
	{
		doverb_store();
		return;
	}

	# The "mv" verb calls the move handlers for the relevant FSE

	if( $verb eq "mv" )
	{
		doverb_move();
		return;
	}

	# LS tells us what we can find out about the current directory tree
	# nothing is force read. there is a dirscan and that is it.

	if( $verb eq "ls" )
	{
		doverb_ls();
		return;
	}

	# Asks the question if the target is exactly identical to the source
	# and if not, shows the difference.

	if( $verb eq "compare" )
	{
		doverb_compare();
		return;
	}
	if( $verb eq "backup" )
	{
		doverb_backup();
		return;
	}
	if( $verb eq "mkvol" )
	{
		doverb_voladd();
		return;
	}
	if( $verb eq "checksum" )
	{
		doverb_checksum();
		return;
	}
	if( $verb eq "checksum-single" )
	{
		doverb_checksum_single();
		return;
	}
	if( $verb eq "checkpoint" )
	{
		doverb_checkpoint();
		return;
	}
	if( $verb eq "reconstruct" )
	{
		doverb_reconstruct();
		return;
	}

	# Writes a permanent file of this entire tree

	if( $verb eq "snapshot")
	{
		doverb_writeSnapshot();
		return;
	}

	if( $verb eq "rsync")
	{
		doverb_rsync();
		return;
	}



	if( $verb eq "stat")
	{
		doverb_stat();
		return;
	}

	die "Verb $verb not recognized - try $0 help for ideas";

	return;
}




sub doverb_help
{
	print <<HERE;

gfs - a universal tool for file handling with checksums

Moves, snapshots and searches for duplicates with a minimum of disk activity.

Unless otherwise instructed, GFS avoids disk access whenever possible. If
meta-data about the size, modification date, or checksum is already available,
it is used for the operation regardless of its age (although you might get a
warning if its too old.) You can force information to be more up to date by
setting a guard time with -G. This is the number of seconds old that metadata
is valid (either stat or hash). Setting guard to 0 means that basically no
metadata caching is done, the most conservative (and slowest) approach.

Future feature: Checksums are not typically forced by the -G switch unless
there is some reason to doubt them (such as a changed size or modification
date. If you really want everything recalculated, set the --force-checksum.)

gfs ls file1 [... file-n]

	Prints out each file and the data known about it. Does not force any new
	calculations or checksums unless a guard argument is in place.

gfs rsync [source1 .. source-n] <target>

	Moves or copies files so that target looks exactly like the merger
	of its sources. Mostly implemented.

gfs compare [source1 .. source-n] <target>

	Checks if two directories contain exactly the same files. A report is
	generated for spurious, incorrect, missing and matched files. Directories
	are not quite implemented properly yet.

gfs snapshot file1 [... filen]

    Writes a file describing the current state of the listed files. Checksums
    / stats if not present are forced, otherwise, no unnecessary disk activity
    is created.

gfs lsdup [source1 .. source-n] target [--all]

    For every file in target tree, reports which is duplicated
    in the target or source trees.

    --all forces a report for every file, not just duplicates (not yet
      implemented)

HERE

}

# these sub verbs could change at any time

sub doverb_debug()
{
	my $command = shift @ARGV;

	if( $command eq 'dump' )
	{
		my $name = shift @ARGV;
		my $tk = TruthKeeper::get();
		my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $name );
		my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};
		$targetGhost->printDebug();
	}
	elsif( $command eq 'cleargfs' )
	{
		system( "find . -name '.gfs_ip' -print0  | xargs -0 rm -v" );
	}
	elsif( $command eq 'dbdump-hash')
	{
		my $gdb = GhostDatabase->getCore();
		$gdb->debugDumpDB( $gdb->{HASH_TO_AFN_DB});

	}
		elsif( $command eq 'dbdump-afn')
	{
		my $gdb = GhostDatabase->getCore();
		$gdb->debugDumpDB( $gdb->{AFN_TO_GHOST_DB});
	}



	elsif( $command eq 'dbtest')
	{
		
		my $gdb = GhostDatabase->getCore();
		$gdb->selftest();
	}
	elsif( $command eq 'lschildren' )
	{
		my $name = shift @ARGV;
		my $tk = TruthKeeper::get();
		my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $name );
		my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};
		my $lfns = $targetGhost->getChildrenLFNs();
		print "I belive the contents of [$name] is:\n";
		print join "\n", @$lfns;
		print "\n";
	}
	elsif( $command eq 'sigtest' )
	{
		my $name = shift @ARGV;
		my $tk = TruthKeeper::get();
		my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $name );
		my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};
		my $lfns = $targetGhost->getChildrenLFNs();
		print join "\n", @$lfns;
		foreach my $l (@$lfns)
		{
			my $g = $tk->obtainGhostForLFN( $l );
			my $sigGhost = $g->cloneForSignature();
			print $sigGhost->serialize(pathMode=>'strict-basename');
			print "\n";

		}
		print" -----\n";
		$targetGhost->calculateSignatureHashOverChildren();

	}
	elsif( $command eq 'crh-slow')
	{
		my $sourceArg = shift @ARGV;
		my $targetArg = shift @ARGV;
		

		my $tk = TruthKeeper::get();
		my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $targetArg );
		my ($sourceGS, $sourceStash) = $tk->makeGhostsFromCommandLine( $sourceArg );
		my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};
		my( $sourceUserFN, $sourceFqlfn, $sourceGhost ) = @{$sourceStash->[0]};
		
		$targetGhost->findDuplicateGhostsUnderTreeFullScan($sourceGhost);
	}
	elsif( $command eq 'crh-fast')
	{
		my $sourceArg = shift @ARGV;
		my $targetArg = shift @ARGV;
		

		my $tk = TruthKeeper::get();
		my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $targetArg );
		my ($sourceGS, $sourceStash) = $tk->makeGhostsFromCommandLine( $sourceArg );
		my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};
		my( $sourceUserFN, $sourceFqlfn, $sourceGhost ) = @{$sourceStash->[0]};
		
		# $targetGhost->findAFNsForHash($sourceGhost);
	}
	else
	{
		die "Unrecognized debug command: [$command].";
	}





}



sub doverb_test
{
	TestEnvironment->go();


}



# doverb_store
#
# Simple actions for using the OJX. 

sub doverb_store()
{
	my $origArg = @ARGV;

	my $name = shift @ARGV;
	my $value = shift @ARGV;

	my $tk = TruthKeeper::get();

	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $value );
	my ($sourceGS, $sourceStash) = $tk->makeGhostsFromCommandLine( $name );

	my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};
	my( $sourceUserFN, $sourceFqlfn, $sourceGhost ) = @{$sourceStash->[0]};

	$targetGhost->store( $sourceGhost );
}

sub doverb_backup()
{
	my $command = shift @ARGV;

	if( $command eq 'run' )
	{
		doverb_backup_run();
	}
	else
	{
		die "Unrecognized backup command: $command.";
	}
}

# For every named file, ask if it is present in the destination path We'd
# rather not do a recurive check, save this for a checkpoint operation
#
# I don't know if ghost stores are the right way to handle this. they would be
# unable to reconstruct the hash filters from disk in an efficient way. (E.g.
# BDB, or bloom filters, etc.)
#
# So I'm going to instead implement some ghost semantics for this type of
# question with the idea that we can use the AFN caches and other things over time.
#
# This is redundant functionality to the GhostStore approach, but I think will be needed
# for scalability and performance reasons. 
#
# Ghost->getHashUnderPath();

sub doverb_backup_run()
{
	my $target = pop @ARGV;
	my @source = @ARGV;
	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $target );
	my ($sourceGS, $sourceStash) = $tk->makeGhostsFromCommandLine( @source );
	
	my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};

	if( not $targetGhost->exists() )
	{
		die "Cannot stat() target: $targetUserFN! $!";
	}

	die unless $targetGhost->canHaveChildren();

	my ($targetHandler, $targetRoot, $targetPath)  = $targetGhost->getLFNcompontents();

	my $verbose = 1;

	my $sourceGSiterator = $sourceGS->getIterator();
	while( my $g = $sourceGSiterator->next() )
	{
		print "--- BACKUP -------------------\n" if $verbose;

		print "targetGhost::::" . $targetGhost->makeDebugString();

		my $sourceLFN = $g->lfn();
		my $sourcePath = $g->getPath(); 
		my $basename = basename $g->getPath();
		my $newPath = File::Spec->catfile( $targetPath, "backup-$$", $sourcePath );
		my $destLFN = main::assembleLFN( $targetHandler, $targetRoot, $newPath );



		#print "--- BACKUP -------------------\n" if $verbose;
		print "[$sourcePath] -> [$newPath] ($destLFN)\n" if $verbose;


		if( $g->canHaveChildren() )
		{
			print "Skipping directory\n";
			next;
			# TODO, fix
		}

		my $dup = $targetGhost->findDuplicateUnderTree($g,$targetFqlfn,1);

		if( $dup )
		{
			print "OK   $sourcePath\n";
		}
		else
		{
			print "COPY $sourcePath -> $newPath\n";
			my $destGhost = $tk->obtainGhostForLFN( $destLFN );
			die	if( $destGhost->exists() );
			$destGhost->store( $g );

		}

		# how to implement?
		# one way is to hit BDB
		#    we first look for size duplicates across that entire path
		#        then check the hashes
		#        if too many, we force a hash strategy
		#    second way is to check for a hash
		#        and then filter out results not under that path
		#	 the final check is hasAcceptableChecksum() 
		#
		# a volume would be able to do this more efficiently by letting us
		# create a BDB locally
		# 
		# if we don't trust BDB is up to date, we'd have to checkpoint the working tree entirely.
		# ghost can pass this up to its FSE (And should) 






	}






}


sub doverb_voladd()
{
	my $origArg = @ARGV;

	my $name = shift @ARGV;

	my $tk = TruthKeeper::get();

	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( @ARGV );
	my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};

	die "not implemented."
}



sub doverb_move()
{
	my $origArg = @ARGV;

	die "Must give EXACTLY 2 arguments" if( $origArg != 2 );

	my $src = shift @ARGV;
	my $dest = shift @ARGV;

	my $tk = TruthKeeper::get();

	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $dest );
	my ($sourceGS, $sourceStash) = $tk->makeGhostsFromCommandLine( $src );

	my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};
	my( $sourceUserFN, $sourceFqlfn, $sourceGhost ) = @{$sourceStash->[0]};

	$sourceGhost->moveGhost( $targetGhost );
}



# doverb_pointer
#
# Simple actions for using the OJX. 

sub doverb_pointer()
{
	my $origArg = @ARGV;

	my $name = shift @ARGV;
	my $value = shift @ARGV;

	my $ojx = $main::coreOjxFSE;

	print "ARGV=@ARGV ---$origArg\n";

	die "Too many arguments" if( $origArg > 2 );

	if( $origArg> 1 )
	{
		print "Pointer [$name] now set to [$value]\n";
		$ojx->setPointer( $name, $value );
		return;
	}

	if( $origArg > 0 )
	{
		
		$value = $ojx->getPointer( $name );
		print "Pointer [$name] is currently: [$value]\n";
	}

}

# doverb_writeSnapshot - handle the write-snapshot command
#
# for each item listed, shows what we know about it -- no recursion, no forced 
# characterization

sub doverb_writeSnapshot()
{
	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( @ARGV );

	my $i = $targetGS->getIterator();

	my $targetFilename = "snapshot-$$.out";
	my $targetLFN = assembleLFN( "snap", $targetFilename, "" );
	my $targetRoot = $tk->obtainGhostForLFN( $targetLFN );
	my $targetFSE = FSEFactory->getFSEHandlerForGhost( $targetRoot );

	while( my $g = $i->next() )
	{
		debug "Write Snapshot - Got Ghost: [$g]\n";

		if( not $g->canHaveChildren() )
		{
			$g->forceCharacterization();
		}

		# $g->printDebug();

		$targetFSE->absorb($g);

		# $store->addGhost( $g );
	}

	$targetFSE->finalize();

	# $store->writeSnapshotToDisk( "snapshot-$$.out");
}



sub doverb_compare()
{
	my $target = pop @ARGV;
	my @source = @ARGV;

	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $target );
	my ($sourceGS, $sourceStash) = $tk->makeGhostsFromCommandLine( @source );
	
	my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};

	if( not $targetGhost->exists() )
	{
		die "Cannot stat() target: $targetUserFN! $!";
	}

	die unless $targetGhost->canHaveChildren();

	my ($targetHandler, $targetRoot, $targetPath)  = $targetGhost->getLFNcompontents();

	my $gst = new GhostStateTransform();

	my $targetGSiterator = $targetGS->getIterator();
	while( my $g = $targetGSiterator->next() )
	{	
		$gst->setOriginal($g);
	}

	my $sourceGSiterator = $sourceGS->getIterator();
	while( my $g = $sourceGSiterator->next() )
	{
		my $sourceLFN = $g->lfn();
		my $sourcePath = $g->getPath(); 
		my $basename = basename $g->getPath();
		my $newPath = File::Spec->catfile( $targetPath, $sourcePath );
		my $targetLFN = main::assembleLFN( $targetHandler, $targetRoot, $newPath );

		print "--- INITIAL SCAN -------------------\n";
		print "[$sourcePath] -> [$newPath]\n";
		#print "Thing I'm iterating on:\n";
		#$g->printDebug();

		$gst->setTargetState( $targetLFN, $g );
	}

#	$gst->printDebug();
#	$gst->printDebugWithPaths();

	$gst->doforeachLFN( sub
	{
		my $self = shift;
		my $lfn = shift;

		my $status = "";

		if( $gst->LFNtest_isComplete($lfn) )
		{	
			$status = "Match";
		}

		if( $gst->LFNtest_isMissing($lfn) )
		{	
			$status .= "Missing";
		}

		if( $gst->LFNtest_isSpurious($lfn) )
		{	
			$status .= "Spurious";
		}

		if( $gst->LFNtest_isIncorrect($lfn) )
		{	
			$status .= "Incorrect checksum";
		}

		print "$lfn -> $status\n";
	});


}








# doverb_ls - handle the LS command
#
# for each item listed, shows what we know about it -- no recursion, no forced 
# characterization. 

sub doverb_ls()
{
	my $tk = TruthKeeper::get();

	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( @ARGV );

	foreach my $tuple (@$targetStash)
	{
		my( $userFN, $fqlfn, $g ) = @$tuple;

		# $g->printDebug();

		my $fullHash = $g->fullHash() || '<not calculated>';
		my $lastFullHash = $g->lastFullHash();

		my $lfh_string = (defined $lastFullHash) ? strftime( "%c", localtime( $lastFullHash) ) : '<not calculated>';

		my $d = (defined $lastFullHash) ? expressRelativeTime( $main::SCRIPT_START - $lastFullHash ) : "x";
		my $type = $g->type() || '?';

		$lfh_string .= "($d)";

		print +(join "\t", $type,$fullHash,$lfh_string,$userFN) . "\n";
	}
}


# doverb_checksum - checksum the files we are given
#
#

sub doverb_checksum()
{
	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( @ARGV );
	my $i = $targetGS->getIterator();
	while( my $g = $i->next() )
	{
		my $lfn = shift; 
		next if $g->canHaveChildren();

		my $fullHash;

		if( $g->exists() )
		{
			$fullHash = $g->getFullHash();
		}
		else
		{
			$fullHash = "<file not found>";
		}
		# $g->printDebug();

		print +(join "\t", $fullHash, $g->lfn()), "\n";

		$g->flush();
	}
}








# doverb_checkpoint  - ensures the paths we are given
# are fully checkpointed, and that all metadata is up to date.
#
#

sub doverb_checkpoint()
{
	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( @ARGV );
	my $i = $targetGS->getIterator();
	foreach my $tuple (@$targetStash)
	{
		my( $userFN, $fqlfn, $g ) = @$tuple;
	
		if( $g->exists() )
		{
			# $g->calculateDeepFields();
			my $deepSize = $g->getDeepSize();
			my $deepCount = $g->getDeepCount();
			my $fullHash = $g->getFullHash();

			print "$fqlfn: $deepSize   $deepCount   $fullHash\n";

		}
		else
		{
			print "$fqlfn: file not found\n";
		}
	
	


		$g->flush();
	}
}

sub reconstructTestAction
{
#	my $self = shift;
	my $ghost = shift;

	# First, look for an exact match

	my $gdb = GhostDatabase->getCore();
	$gdb->findAFNsForHash( $ghost );

	my $lfn = $ghost->lfn();
	print "reconstructAction: LFN: $lfn\n";

	my $func = sub { my( $candidate, $target ) = @_; 
			$candidate->isSameFilename( $target) ? $CODE_SKIP_DUPLICATE : $candidate };

	my @dups = $ghost->forDuplicatesMap( $func );


	foreach my $d (@dups)
	{
		my $x = $d->quickDebugString();
		print "     -> $x\n"

	}


	if( @dups > 0 )
	{	
		print "reconstructAction: Found duplicate!\n";
		return 1;
	}
	else
	{
		print "reconstructAction: No duplicate found, checking children..\n";

	}

	# I must be able to return "true" for every child

	if( $ghost->canHaveChildren() )
	{
		my @c = $ghost->getChildren();
		my @answers;
		foreach my $g (@c)
		{
			my $lfn = $g->lfn();
			main::debugLevel(1);








			$g->flush();
			main::debugLevel(-1);
		} 


	}
	else
	{
		# no children, so reconstruction not possible
		return 0; 
	}

}


sub doverb_reconstruct()
{
	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( @ARGV );
	my $i = $targetGS->getIterator();
	foreach my $tuple (@$targetStash)
	{
		my( $userFN, $fqlfn, $g ) = @$tuple;
	
		if( $g->exists() )
		{

			reconstructTestAction($g);



			# $g->calculateDeepFields();
			my $deepSize = $g->getDeepSize();
			my $deepCount = $g->getDeepCount();
			my $fullHash = $g->getFullHash();

			print "$fqlfn: $deepSize   $deepCount   $fullHash\n";

		}
		else
		{
			print "$fqlfn: file not found\n";
		}
	
	


		$g->flush();
	}
}




sub doverb_checksum_single()
{
	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( @ARGV );
	my $i = $targetGS->getIterator();
	my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};


	my $c = $targetGhost->getFullHash();

	print "Full hash is $c\n";
	$debugDump{run}->{getFullHash} = $c;

	$targetGhost->flush();
}



# Scans, generating a stat for every file recursively.

sub doverb_stat()
{
	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( @ARGV );
	my $i = $targetGS->getIterator();
	while( my $g = $i->next() )
	{
		my $lfn = shift; 
		my $fullHash = $g->getFullHash();
		# $g->printDebug();

		print +(join "\t", $fullHash, $g->lfn()), "\n";
	}
}

sub doverb_rsync
{
	my $target = pop @ARGV;
	my @source = @ARGV;

	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $target );
	my ($sourceGS, $sourceStash) = $tk->makeGhostsFromCommandLine( @source );
	
	my( $targetUserFN, $targetFqlfn, $targetGhost ) = @{$targetStash->[0]};

	if( not $targetGhost->exists() )
	{
		die "Cannot stat() target: $targetUserFN! $!";
	}

	die unless $targetGhost->canHaveChildren();

	my ($targetHandler, $targetRoot, $targetPath)  = $targetGhost->getLFNcompontents();

	my $gst = new GhostStateTransform();
	my $targetGSiterator = $targetGS->getIterator();
	while( my $g = $targetGSiterator->next() )
	{	
		$gst->setOriginal($g);
	}

	$gst->printDebug();

	my $sourceGSiterator = $sourceGS->getIterator();
	while( my $g = $sourceGSiterator->next() )
	{
		my $sourceLFN = $g->lfn();
		next if ! $g->isSingleFile();
		my $sourcePath = $g->getPath(); 
		my $basename = basename $g->getPath();
		my $newPath = File::Spec->catfile( $targetPath, $sourcePath );
		my $targetLFN = main::assembleLFN( $targetHandler, $targetRoot, $newPath );

		print "--- INITIAL SCAN -------------------\n";
		print "[$sourcePath] -> [$newPath]\n";
		#print "Thing I'm iterating on:\n";
		#$g->printDebug();

		$gst->setTargetState( $targetLFN, $g );
	}

	$gst->createClearanceMoves();
	print "******************* Post Clearance\n";
	$gst->printDebug();
	print "******************* Post Clearance\n";
	$gst->printDebugWithPaths();


	$gst->handlePillageFromGS( $gst->orphanGS() );

	print "******************* Post Orphan Pillage\n";
	$gst->printDebug();
	print "******************* Post Orphan Pillage\n";
	$gst->printDebugWithPaths();


	$gst->handleLocalCopyFromGS( $gst->obtainCurrentStateAsGS() );

	print "******************* LocalCopy \n";
	$gst->printDebug();
	print "******************* LocalCopy\n";
	$gst->printDebugWithPaths();


	$gst->handleLongHaulCopyFromGS( $sourceGS );

	print "******************* Long Haul \n";
	$gst->printDebug();
	print "******************* Long Haul \n";
	$gst->printDebugWithPaths();

	$gst->handleZeroLengthFiles();

	my $xgs = $gst->obtainCurrentStateAsGS();



	$gst->handleLocalCopyFromGS( $xgs );


	
	$gst->verifyCorrectness();


	$gst->printWorklist();

	$gst->execute();

	#$gst->printDebug();

	# at this point, we wantt the GST to generate all ghosts (in present locations)
	# currently under the tree
	# iterate over all current ghosts

}


###########
# Lsdup: A B C - for every file in C, say which are copied in A and or B and C (and where)
# Ghost-tools tries to be minimal about hitting the disk, but at a minimum,
# a duplicate requires that at some point GFS has to have a full SHA-1 match of the file.
# 
# Tells you where the duplicates are, and when they were last checked or verified
#
# foreach c (where size != 0)
# c->findDuplicates( $g );
# b->findDuplicates( $g );
# a->findDuplicates( $g );
# findDuplicates psucdocode
#    get ghost G for FN
#    find candidates - $fse->listAllFilesWithSize( $size )
#        lafby size, first time its called iterates over all FSE, hashing up sizes
#		 next, for each we do the test "$g->hasIdenticalContent($g)"
#		 	HIC first rules out size, then mod-date, then finally fullhash

sub doverb_lsdup()
{
	my $target = pop @ARGV;
	my @source = @ARGV;

	my $tk = TruthKeeper::get();
	my ($targetGS, $targetStash) = $tk->makeGhostsFromCommandLine( $target );
	my ($sourceGS, $sourceStash) = $tk->makeGhostsFromCommandLine( @source );
	my $i = $targetGS->getIterator();

	my $dup_count = 0;
	my $dup_size = 0;
	my $dup_size_interior = 0;
	my $dup_count_interior = 0;
	my $total_files = 0;
	my @report; 
	my $asWeGoPrint = 1;

	while( my $g = $i->next() )
	{
		my $lfn = $g->lfn();

		next unless $g->isFile();
		next if fileIsUsuallyIgnored( $lfn );

		$total_files++;

	#	print "LS Dup -handling LFN:[$lfn]\n";

		my @tdups = $targetGS->findOtherDuplicates( $g );
		my @sdups = $sourceGS->findOtherDuplicates( $g );

		my $dupCount = @tdups + @sdups;

		if( $dupCount > 0 )
		{
			$dup_count_interior++;
		}

		if( $asWeGoPrint )
		{
			printf "[%3d]_________%s\n", $dupCount, $lfn;
		}

		if( @tdups > 0 )
		{	
			#print "    Duplicate in local tree: ($target)\n";

			foreach my $d (@tdups)
			{
				my $dfn = $d->lfn();
 
				print "      Target: $dfn\n" if $asWeGoPrint;
				$dup_count++;
				$dup_size += $d->getSize();
				$dup_size_interior += $d->getSize();
				# $d->printDebug();
			}
		}

		if( @sdups > 0 )
		{
			$dup_size_interior += $g->getSize();
			#print "    Duplicate in source trees (@ARGV):\n";
			foreach my $d (@sdups)
			{
				my $dfn = $d->lfn();

				print "      Source: $dfn\n" if $asWeGoPrint;
				$dup_count++;
				$dup_size += $d->getSize();
				# $d->printDebug();
			}
		}

		push @report, [$g, \@tdups, \@sdups];
	}

	print "Duplicate report: size X (target dups / source dups ) filename\n";

	foreach my $line (reverse sort { $a->[0]->getSize() <=>  $b->[0]->getSize() } @report )
	{
		my ($g, $tdups, $sdups ) = @$line;
		my $file = $g->lfn();
		my $size = $g->size();
		my $i = 0 + @$tdups;
		my $e = 0 + @$sdups;

		if( $i > 0 or $e > 0 or $OPT_ALL )
		{	
			print "$size X ($i/$e) $file \n";
		}
	}

	print "LSDup finished\n";
	print "I found $dup_count_interior files that were duplicated in target ($target),\n";
	print "when searching among the target plus source files: @ARGV\n";
	print "occupying $dup_size unnecessary space across the whole filesystem over $dup_count files.\n";
	print "Within the target itself, this represents $dup_size_interior bytes.\n";
	print "There were $total_files in the target directory\n";
}

# Write the in place descriptors in each directory named

sub doverb_writeDescriptor()
{
	die "dead";
	my $store = GhostStore->new();

	my $fse = new FilesystemExplorer::FS();
	$fse->setRoots( @ARGV );

	# sort of a lazy way to do it -- forces
	# a checksum computation, which should
	# populate the in place descriptors

	# a better way would be to enter each directory
	# and call some specific "build for x" function

	while( defined( my $file = $fse->next() ) )
	{
		print "Verb WD - Scanning: [$file]\n";

		if( -f $file )
		{
			$fse->forceGhostCharacterization( $file );
			my $fullHash = $fse->getFullHash( $file );
			print "Verb WD: fullhash = $fullHash\n";
		}
		else
		{
			print "Verb WD - Not a regular file: [$file]\n";
		}

	
	}
}

# A hard ignore is a filename that we must pretend never existed
# it will not factor into any directory checksums
# or be saved to any ghost stores

sub isHardIgnore
{
	my $fn = shift;

	die "Assert: $fn should be a path" if not main::assert_regularpath( $fn );

	my $b = basename $fn;	

	return 1 if $b =~ /$DESCRIPTOR_FILENAME$/;

	return 0;
}




# Sanity check that a path is indeed canonicalized 
#
# GFS relies on all paths being canonicalized so that text matching occurs
# properly. Otherwise ./foo and foo will not text match and it will appear
# like they are different files. Any routines that brings in a "net new" path
# to the system should convert it to a cpath.

sub assert_cpath($)
{
	my $lfn = shift;
	assert_regularpath($lfn);
	my $clfn = File::Spec->canonpath( $lfn );
	die "ASSERT CPATH FAILED: $lfn ne $clfn" if $lfn ne $clfn; 
}

# Sanity check that in places where an operation is to work
# on a regular path that it actually is one.

sub assert_regularpath($)
{
	my $path = shift;
	my $c = () = $path =~ m/\:/go;
	#print "Testing [$path] - got $c\n";
	die "ASSERT regularpath [$path] - failed -- smells like a FQLFN" if( $c == 2 );
	return 1; 
}

# Navigates up to the parent (usually by adding a ..)

sub rewriteLFNPathParent
{
	my $lfn = shift;

	my( $handler, $root, $path ) = parseFQLFN( $lfn );

	my $dir = $path;
	my $updir = File::Spec->updir();

	my $newPath = File::Spec->catfile( $dir, $updir );
	my $p = File::Spec->canonpath($newPath);
	return assembleLFN( $handler, $root, $p );

}

# Strips down to the directory name (takes off the basename, basically)

sub rewriteLFNPathDirname
{
	my $lfn = shift;

	my( $handler, $root, $path ) = parseFQLFN( $lfn );

	my $dir = dirname $path;

	my $p = File::Spec->canonpath($dir);
	return assembleLFN( $handler, $root, $p );

}

# Returns a fully cleaned up absolute path name for this file
# Initial testing has shown this handles foo/../../ properly, etc
# probably requires a ton of stats in cases where there are ..
# but doesn't appear to be too onerous for usual path names

sub rewriteLFNPathAbsolute
{
	my $lfn = shift;
	die unless defined $lfn;
	my( $handler, $root, $path ) = parseFQLFN( $lfn );
	die "only fs roots can be made into absolute paths ($lfn)-($root)" unless $handler eq 'fs';



	if( 0 )
	{
		debug "Test of rewrite:\n";
		debug "   me: [$path]\n";

	  	my $cwd1 = abs_path( $path );

	 	debug "Using Cwd Abs_path:\n"; 
	  	debug "   me: [$cwd1]\n";

	  	my $abs1 = File::Spec->rel2abs( $path );

	 	debug "Using rel2abs:\n"; 
	  	debug "   me: [$abs1]\n";
	}



	#print "Before: $path\n";
	$path = File::Spec->rel2abs( $path );
	# $path = abs_path( $path );
	#print "After: $path\n";

	return assembleLFN( $handler, $root, $path );
}

sub rewriteLFNreplaceRoot
{
	my $lfn = shift;
	my $new = shift;

	die unless defined $lfn;
	die unless defined $new; 

	my( $handler, $root, $path ) = parseFQLFN( $lfn );
	$root = $new;
	return assembleLFN( $handler, $root, $path );
}

# Takes an LFN and removes the leading directory from the path component

sub rewriteLFNPathToBasename
{
	my $lfn = shift;

	my( $handler, $root, $path ) = parseFQLFN( $lfn );
	my( $fn, $dir ) = fileparse( $path );
	return assembleLFN( $handler, $root, $fn );
}

# Takes an LFN and adds a leading directory portion onto the path

sub rewriteLFNwithLeadingDirectory
{
	my $lfn = shift;
	my $leadingDir = shift;

	my( $handler, $root, $path ) = parseFQLFN( $lfn );
	$path = File::Spec->catfile( $leadingDir , $path );
	$path = main::canonize( $path );
	return assembleLFN( $handler, $root, $path);
}

# Pass it a path (not a FQLFN) and you'll get the canonical version
# which can be file compared

sub canonize($)
{
	my $lfn = shift;

	assert_regularpath( $lfn );

	my $clfn = File::Spec->canonpath( $lfn );

	# print "Canonicalize: $lfn ---> $clfn\n";	

	return $clfn;
}

# Assembles a FQLFN from its consituent parts

sub assembleLFN
{
	my ($handler, $root, $path ) = @_;

	die unless length $handler >0;
	die unless defined $root;
	die unless defined $path;

	return join ':', $handler, $root, $path;
}


# Splits out a FQLFN into its three parts

sub parseFQLFN
{
	my $lfn = shift;

	die "parseFQLFN passed a undefined value" if not defined $lfn;

#	my @parts = split( ':', $lfn );
	my (@parts) = ( $lfn =~ m/^(\w+)\:([^:]*)\:(.*)/ );

	my ($handler, $root, $path ) = @parts;

	die "assert: parseFQLFN [$lfn] - does not have 3 parts!" unless scalar(@parts) == 3;
	#print "ParseLFN = [$lfn] -> handler:[$handler] root:[$root] lfn:[$path]\n";

	return @parts; 
}

# Does the gueswork of taking a partial user provided LFN and figuring
# out the intent and fully qualifying it

sub fullyQualifyLFN
{
	my $lfn = shift;

	my @c = split( ':', $lfn );

	my $handler;
	my $root;
	my $path;

	# first handle the case of bareword stuff like ./quxx and bar or testa/file1.txt

	if( 0 )
	{
		print "fullyQualifyLFN: Testing for element count";
		print scalar @c;
		print "\n";
	}

	if( scalar(@c) == 1 )
	{
		$handler = "fs";
		$root = "root";
		$path = $lfn;
	}
	elsif( @c < 3 )
	{
		# Yucky case - user has given us 2 things, what does he or she mean?
		# first, lets see if the first thing is one of our keywords
		# if so, we can usually assume the next part is the root

		if( $c[0] =~ /^fs|snap|remote|obj|vol/ )
		{
			$handler = $c[0];
			$root = $c[1];
			$path = "";

			warn "Interpolating LFN -- did you mean to leave off a path? Assuming your intent was handler:[$handler] root:[$root] path:[$path] ";
		}
		else
		{
			# In this case, best to assume that the first thing is the root
			# but what handler to use?

			$handler = "";
			$root = $c[0];
			$path = $c[1];

			die "Cannot infer compound path - [$lfn] - please specify a handler";
		}
	}
	elsif( @c > 3 )
	{
		die "Ambiguous - too many colons in this filename. (Sorry we don't like colons in filenames, at least not when provided on the command line)";
	}
	else
	{
		($handler, $root, $path ) = @c;
	}

	$path = main::canonize( $path );

	# debug "FULLY QUALIFY LFN:[$lfn] -> handler:[$handler] root:[$root] path:[$path]\n";

	return assembleLFN( $handler, $root, $path );
}


# Stat 

sub statModeGen_error
{	
	my $errno = shift; 
	return "ERR/" . $errno;
}

sub statModeParse_isError
{
	my $stat = shift;
	return 1 if $stat =~ /^ERR/;
	return 0; 
}



# Hash parsing tools live here

# Breaks apart a hash into its three components. 

sub extractHashComponents
{
	my $hashString = shift;

	my ($algorithim, $meta, $digest ) = split '/', $hashString;

	die unless defined $algorithim;
	die unless defined $meta;
	die unless defined $digest;

	return [ $algorithim, $meta, $digest  ];
}

sub globalMkPath
{
	my $p = shift; 
	# debug "Mkpath: $p";
	File::Path::make_path( $p );

	$@ and die "Couldn't create dir path: $@";
    die "Did not find new path" if not -d $p;

}

# Encapsulation around a fast disk-based database of ghost information

package GhostDatabase;

use BerkeleyDB;
use BerkeleyDB::Hash;
use BerkeleyDB::Btree;
use Storable qw( freeze thaw );

sub new
{
	my $class = shift;
	my $path = shift;
	my $self = {};
	bless $self, $class;

	$self->{PATH} = $path;
	return $self; 
}

sub debug($)
{
	my $a = shift;
	main::debug( "GDB: " . $a );
}




sub getCore
{
	my $class = shift;

	return $main::coreGhostDatabase;
}


sub init
{
	my $self = shift;

	my $DBDIR = $self->{PATH};

	main::globalMkPath( $DBDIR );

	my $bdb_env = new BerkeleyDB::Env 
	    -Verbose => 1,
	    -Home => $DBDIR,
	    -Flags => DB_CREATE|DB_INIT_MPOOL|DB_INIT_CDB,
	    -ErrFile => "$DBDIR/Errors.txt",
	    -ErrPrefix => "GFS"
	    ;

	die "Environment failed: $!, $BerkeleyDB::Error" unless defined $bdb_env;

	my $afnToGhost = new BerkeleyDB::Btree
	    -Flags    => DB_CREATE,
	    -Env => $bdb_env,
	    -Filename => "afn-to-ghost.db";

	die "Failed to create afnToGhost: $!, $BerkeleyDB::Error" unless $afnToGhost;
	$self->{AFN_TO_GHOST_DB} = $afnToGhost;	

	my $hashToAFN = new BerkeleyDB::Hash
	    -Flags    => DB_CREATE,
	   # -Propery  => DB_DUP,
	    -Env => $bdb_env,
	    -Filename => "hash-to-afn.db";

	die "Failed to create hashToAFN: $!, $BerkeleyDB::Error" unless $hashToAFN;
	$self->{HASH_TO_AFN_DB} = $hashToAFN;	

#	my $status = $afnToGhost->db_put("sdfsf","bar");
#	ckStatus( $status );

}

sub selftest
{
	my $self = shift;
	my $db;

	$db = $self->{HASH_TO_AFN_DB};

	my %hashesSeen;

	{
		my ($k, $v) = ("", "") ;
		my $cursor = $db->db_cursor() ;
		while ($cursor->c_get($k, $v, DB_NEXT) == 0)
		 { 
		 	$hashesSeen{$k}++;

		 	print "$k -> $v\n" ;

		 	my $afns = thaw $v;
		 	foreach my $afn (@$afns )
			{
				my $g = $self->findGhostByAFN( $afn );
				die "AFN in HashToAFN database not found in afn DB" if not defined $g;
				debug $g->quickDebugString();
				die "Hash inconsistency between HashToAfn and AfnToGhost: the hash->afn database says object has one hash,".  
				     "but the AFN->ghost database has a different hash" if $g->fullHash() ne $k;
			}	
		}
	}

	{
		$db = $self->{AFN_TO_GHOST_DB};
		my ($k, $v) = ("", "") ;
		my $cursor = $db->db_cursor() ;
		while ($cursor->c_get($k, $v, DB_NEXT) == 0)
		 { 
		 	print "$k -> $v\n" ;

		 	my $g = Ghost->newFromSerialized( $v ); 
		 	if( defined $g->fullHash() )
		 	{
		 		die unless $hashesSeen{$g->fullHash} > 0;
		 	}

		}
	}	

	print "Database consistency check passed!\n";
}

sub ckStatus
{
	my $status = shift;

	die "DB error: $!, $BerkeleyDB::Error" if $status; 
}


sub debugDumpDB
{
	my $self = shift;
	my $db = shift;


	my ($k, $v) = ("", "") ;
	my $cursor = $db->db_cursor() ;
	while ($cursor->c_get($k, $v, DB_NEXT) == 0)
	 { 
	 	print "$k\n   -> $v\n\n" 
	}
}

my $gdbFindDebug = 1; 

sub findAFNsbyHashAndPrefix
{
	my $self = shift;
	my $hash = shift;
	my $prefix = shift;

	debug "Looking for hash:$hash under prefix:[$prefix]\n" if $gdbFindDebug;

	my $c = $self->findAFNsForHash($hash);
	my $len = length $prefix;
	my @r; 

	foreach my $afn ( @$c )
	{
		debug "  --> AFN match: $afn" if $gdbFindDebug;
		next if length($afn) < $len;
		my $a = substr $afn,0,$len;
		if( $a eq $prefix)
		{
			debug "      -> MATCH subpath!" if $gdbFindDebug;
			push @r, $afn; 
		}
	}

	return \@r;
}

sub findGhostByAFN
{
	my $self = shift;
	my $afn = shift;

	if( exists $self->{AFN_TO_GHOST_CACHE}->{$afn} )
	{
		return $self->{AFN_TO_GHOST_CACHE}->{$afn};
	}

	my $value;

	my $status = $self->{AFN_TO_GHOST_DB}->db_get( $afn, $value );
	# ckStatus( $status );
	$main::run_db_gets ++;

	if( defined $value )
	{
		#print "Got from DB: $value\n" if $gdbDebug;
		my $ghost = Ghost->newFromSerialized( $value );
		$ghost->addDebugProvenance( "afn/lu($afn)" ) if $provenanceDebug;
		debug "Got from DB:" . $ghost->quickDebugString()  if $gdbDebug;
		$self->{AFN_TO_GHOST_CACHE}->{$afn} = $ghost; 
		return $ghost;
	}

	# Guess we have to make it. This call to make_private() is only supposed
	# to happen in one place inside the TruthKeeper but I think its OK since
	# i'm not sure I want these things in the TK cache. 

	my $gAFN = Ghost->make_private( $afn );
	$gAFN->addDebugProvenance( "fbAFN($afn)" );

	$self->{AFN_TO_GHOST_CACHE}->{$afn} = $gAFN;

	return $gAFN; 

}

# Finds all AFNs for the given hash, returns an array reference. 

sub findAFNsForHash
{
	my $self = shift;
	my $hash = shift;

	my $db = $self->{HASH_TO_AFN_DB};
	return $self->performRetreivalOnPerlStructFromKey($db, $hash );
}

sub revokeAFNforHash
{
	my $self = shift;
	my $hash = shift;
	my $afn = shift;

	my $db = $self->{HASH_TO_AFN_DB};

	my $func = 
	sub 
	{ 
		my $var = shift;
		@$var = grep { $_ ne $afn; } @$var;
	};

	$self->performOperationOnPerlStructFromKey( $db, $hash, $func );
}

sub performRetreivalOnPerlStructFromKey
{
	my $self = shift;
	my $db = shift;
	my $key = shift;

	my $content;
	my $unpacked;
	my $status; 

	$main::run_db_gets++;

	die unless defined $db;
	die unless defined $key;


	$status = $db->db_get( $key, $content );
	if( !defined $status or $status == DB_NOTFOUND )
	{	
		return undef; 
	}
	else
	{	
		ckStatus( $status );
		$unpacked = thaw( $content );
		return $unpacked; 
	}

}

sub performOperationOnPerlStructFromKey
{
	my $self = shift;
	my $db = shift;
	my $key = shift;
	my $sub = shift;

	my $content;
	my $unpacked;
	my $status; 

	$status = $db->db_get( $key, $content );
	if( $status == DB_NOTFOUND )
	{	
		$unpacked = [];
	}
	else
	{	
		ckStatus( $status );
		$unpacked = thaw( $content );
	}

	$main::run_db_gets++;
	$main::run_db_puts++;

	$sub->($unpacked);

	$status = $self->{HASH_TO_AFN_DB}->db_put( $key, freeze( $unpacked ) );
	ckStatus( $status );
}

sub storeAFNforHash
{
	my $self = shift;
	my $hash = shift;
	my $afn = shift;

	my $db = $self->{HASH_TO_AFN_DB};

	my $func = 
	sub 
	{ 
		my $var = shift; 
		foreach my $m ( @$var )
		{
			return if $m eq $afn;
		}
		push @$var, $afn;
	};

	$self->performOperationOnPerlStructFromKey( $db, $hash, $func );
}

sub storeGhostToAFN
{
	my $self = shift;
	my $g = shift;
	my $afn = shift;

	my $serialized = $g->serialize();

	print "GDB:STORE: $serialized\n" if $gdbDebug;

	my $status = $self->{AFN_TO_GHOST_DB}->db_put( $afn, $serialized );
	ckStatus( $status );

	$main::run_db_puts ++;
}



sub shutdown
{
	my $self = shift; 
	my $status = $self->{AFN_TO_GHOST_DB}->db_close();
	ckStatus( $status );
}

	# my $gdb = GhostDatabase->getCore();
	# my $absGhost = $gdb->findGhostByAFN( $afn );
	# $absGhost->learnFromGhost( $g );


sub populateDataOnGhost()
{
	my $self = shift;
	my $g = shift;

	my $afn = $g->absoluteLFN();

	my $teacher = $self->findGhostByAFN( $afn );

	if( defined $teacher )
	{
		$g->learnFromGhost( $teacher );
		debug "   Populated ghost data from GDB: " . $g->quickDebugString() if $gdbDebug;
	}
	else
	{
		debug "   No GDB records found";
	}

	return $g; 
}


sub basicUniversalStoreTest
{
	my $self = shift;

	my $env = $self->createTestEnvironment();
	#env->
}

my $saveGhostDebug =0; 


sub saveGhostToStore()
{
	my $self = shift;
	my $g = shift;

	my $afn = $g->absoluteLFN();

	my $absGhost = $self->findGhostByAFN( $afn );

	if( ! defined $absGhost )
	{
		$absGhost = Ghost->make_private( $afn );
		debug "   Ghost not formerly registered, new one created" if $saveGhostDebug;
	}

	$absGhost->learnFromGhost( $g );
	debug "   Added ghost data to GDB: " . $absGhost->quickDebugString() if $saveGhostDebug;

	my $originalAbsFH = $absGhost->fullHash();
	my $originalGhostFH = $g->fullHash(); 

	$absGhost->learnFromGhost( $g );

	if( $absGhost->dirty() == 0 )
	{
		debug "   No new data to return to GDB." . $absGhost->quickDebugString() if $saveGhostDebug;
		return; 
	}

	my $newAbsFH = $absGhost->fullHash();

	if( !defined $newAbsFH )
	{
		if( defined $originalAbsFH )
		{
			CODEPATH( "Revoke AFN/Hash, no new hash");
			debug "   HashChange: Revoked old hash, no new one" if $saveGhostDebug;
			$self->revokeAFNforHash( $originalAbsFH, $afn );
		}
	}
	else
	{
		if( (defined $originalAbsFH) && $newAbsFH ne $originalAbsFH )
		{
			CODEPATH( "Revoke AFN/Hash, new hash");
			debug "   HashChange: Revoked old hash, new has registered" if $saveGhostDebug;
			$self->revokeAFNforHash( $originalAbsFH, $afn );
		}

		$self->storeAFNforHash( $newAbsFH, $afn);
	}

	$self->storeGhostToAFN( $absGhost, $afn );

	debug "   Commited ghost to DB store" if $saveGhostDebug;

	if( $g->hasAcceptableEnumeration() )
	{
		my $buffer = $g->generateTreeSignatureBuffer();
		my $ojx = $main::coreOjxFSE;

		# $ojx->storeScalar($buffer);

		print "+++_+_+_+ ** TO implement: storage of the dirfile -- GOOD TO GO!\n";
	}




	my $id = $absGhost->debugID();
	my $q = $absGhost->quickDebugString();
	debug "<< Commited ghost $id to store $q" if $saveGhostDebug;

	# $g->printDebug();

	if( $g->everWasDirtyThisRun() )
	{
		open FILE, ">>$DIRTYLOGFN" or die;
		print FILE $absGhost->serialize();
		print FILE "\n";
		close FILE; 
	}




	return $g; 
}


# This holds everything that represents the core stat metadata of an object
# except for size, mtime, and mode.  Anything that should be in lock-step with
# these stat fields goes in here. This is really an optimization to prevent
# new fields from unnecessarily being added into ghosts as our concept of
# stat-like metadata expands over time. Metadata that is not lock-tied to the
# stat(3) call should NOT be added here.


package StatStruct;

sub new
{
	my $class = shift;
	my $self = [];
	bless $self, $class;
	return $self; 
}

sub debug($)
{
	my $a = shift;
	main::debug( "statStruct: " . $a );
}

sub loadFromPOSIXstat
{
	my $self = shift;
	my $arr = shift;

	# ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks)

	print "StatStruct: Loaded :" . (join ',', @$arr ) . "\n" if $statStructDebug;

	# drop 2,7,9

	splice( @$arr, 2, 1 );
	splice( @$arr, 6, 1 );
	splice( @$arr, 7, 1 );

	print "StatStruct: Trimed to :" . (join ',', @$arr ) . "\n" if $statStructDebug;

	$self->[0] = $arr;

	return $self;
}

sub serialize
{
	my $self = shift; 

	my $str = join ',', @{$self->[0]};

	debug( "Serialized to: $str") if $statStructDebug;

	return $str;
}

sub deserialize
{
	my $self = shift; 
	my $str = shift;

	die unless defined $str;
	
	debug( "Deserialized from: [$str]") if $statStructDebug;

	my @arr = split ',', $str;
	
	$self->[0] = \@arr;

	return $str;
}

sub isSameAs
{
	my $self = shift;
	my $other = shift;

	die unless ref $self;
	die unless ref $other;

	my $result = 0;

	if( 0 ) # $self == $other)
	{
		$result = 1;
	}
	else
	{
		$result = ($self->serialize() eq $other->serialize() ) ? 1 : 0;
	}

	debug "isSameAs: $self vs $other = $result\n" if $statStructDebug;;

	return $result; 
}

sub hasMeaningfullyChanged
{
	my $self = shift;
	my $other = shift;

	# ($dev,$ino,$nlink,$uid,$gid,$rdev,$atime,$ctime,$blksize,$blocks)

	return 1 if $self->getInode() != $other->getInode();
	return 1 if $self->getCtime() != $other->getCtime();

	return 0;
}


sub getInode
{
	my $self = shift;
	return $self->[0]->[1];
}

sub getCtime
{
	my $self = shift;
	return $self->[0]->[7];
}


# GhostStateTransform Class
#
# Holds the state of a transitional mapping between the current state of the
# world and a desired final state. Provides a lot of tools for manipulating
# this final state and then ultimately checking that it's performed.
#
# The caller starts by informing the object of the LFNs that should be state
# managed. GST will hold onto the original LFNs with setOriginal(). The
# default mode is that these original files are presumed to be the initial
# state. The user can also specify (if they want) a final state.
#
# At this point, move() or copy() commands can be used inside the GST. The GST
# checks to be sure there is coherence between the action and the emerging
# state of the filesystem. There are functions to automatically generate these
# according to certain rules so that the final state is reached.
#
# The GST is done with the currentState = finalState, and a set of work
# instructions are complete. CurrentState and finalStates typically are
# invented LFNs.





package GhostStateTransform;

use base qw(Class::Accessor);
GhostStateTransform->mk_accessors( qw( _lfnState orphanGS) );


sub CODEPATH($)
{	
	my $p = shift; 
	main::CODEPATH( "GST: $p" );
}

sub debug($)
{
	my $a = shift;
	main::debug( "gst: " . $a );
}



sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();

	$self->_lfnState( {} );
	$self->orphanGS( GhostStore->new() );


	$self->{WL} = [];

	return $self;
}

sub _setOriginal
{
	my $self = shift;
	my $lfn = shift;
	my $ghost = shift;

	my $lfnState = $self->_lfnState();
	$lfnState->{$lfn}->[0] = $ghost; 
}

sub _setCurrent
{
	my $self = shift;
	my $lfn = shift;
	my $ghost = shift;

	my $lfnState = $self->_lfnState();
	$lfnState->{$lfn}->[1] = $ghost; 

	# $self->{_curGhostToPath}->{$ghost} = $lfn;
}

sub _setFinal
{
	my $self = shift;
	my $lfn = shift;
	my $ghost = shift;

	my $lfnState = $self->_lfnState();
	$lfnState->{$lfn}->[2] = $ghost; 
}


sub _getOriginal
{
	my $self = shift;
	my $lfn = shift;

	my $lfnState = $self->_lfnState();
	return $lfnState->{$lfn}->[0];
}


sub _getCurrent
{
	my $self = shift;
	my $lfn = shift;

	my $lfnState = $self->_lfnState();
	return $lfnState->{$lfn}->[1];
}


sub _getFinal
{
	my $self = shift;
	my $lfn = shift;

	my $lfnState = $self->_lfnState();
	return $lfnState->{$lfn}->[2];
}


sub setOriginal
{
	my $self = shift;
	my $g = shift;
	
	$self->_setOriginal( $g->lfn(), $g );
	$self->_setCurrent( $g->lfn(), $g );
}

sub setTargetState
{
	my $self = shift;
	my $lfn = shift;
	my $g = shift;

	debug( "Target state for lfn[$lfn] = " . $g->makeDebugString() . "\n" );

	$self->_setFinal( $lfn, $g );
}



sub LFNtest_isComplete()
{
	my $self = shift;
	my $lfn = shift;
		my $lfnState = $self->_lfnState();
	my ( $original, $current, $final ) = @{$lfnState->{$lfn}};
	return 1 if defined $current and defined $final and $current->isDuplicateOf($final);
	return 0; 
}


sub LFNtest_isMissing()
{
	my $self = shift;
	my $lfn = shift;
		my $lfnState = $self->_lfnState();
	my ( $original, $current, $final ) = @{$lfnState->{$lfn}};
	return 1 if !defined $current and defined $final;
	return 0; 

}

sub LFNtest_isSpurious()
{
	my $self = shift;
	my $lfn = shift;
		my $lfnState = $self->_lfnState();
	my ( $original, $current, $final ) = @{$lfnState->{$lfn}};
	return 1 if defined $current and !defined $final;
	return 0; 

}

sub LFNtest_isIncorrect()
{
	my $self = shift;
	my $lfn = shift;
		my $lfnState = $self->_lfnState();
	my ( $original, $current, $final ) = @{$lfnState->{$lfn}};
	return 1 if defined $current and defined $final and !$current->isDuplicateOf($final);
	return 0;
}


sub generateOrphanLFN
{
	my $self = shift;
	my $g = shift;

	# sort of cloned-ish code , maybe unite with generateAlternativeLocation

	$g->getPath(); 
	my $tk = TruthKeeper::get();

	my $newOrphanNameFound = 0;
	my $scramble = 0;
	my $finalNewOrphanLFN = 0; 

	while( not $newOrphanNameFound )
	{
		$scramble++;
		# Calculate a new name for this file
		my $orphanNewPathName = $g->getPath() . "-ORPH-$scramble";
		my $orphanNewLFN = main::assembleLFN( $g->getHandler() , $g->getRoot(), $orphanNewPathName );
		my $orphanGhost = $tk->obtainGhostForLFN( $orphanNewLFN );
		print "       - testing orphan: $orphanNewLFN\n";
		next if $orphanGhost->exists();
		next if defined $self->_getCurrent( $orphanNewLFN );
		next if defined $self->_getFinal( $orphanNewLFN );
		$finalNewOrphanLFN = $orphanNewLFN;
		$newOrphanNameFound = 1;
	}

	return $finalNewOrphanLFN;
}

sub doforeachLFN($&)
{	
	my $self = shift;
	my $function = shift;

	my $entry = 


	my $lfnState = $self->_lfnState();
	foreach my $lfn ( sort keys %$lfnState )
	{
		$function->($self,$lfn);
	}

}

sub printDebug
{
	my $self = shift;

	my $lfnState = $self->_lfnState();
	foreach my $lfn ( sort keys %$lfnState )
	{
		print $self->debugStringForLFN( $lfn,0 )."\n";
	}
}

sub printDebugWithPaths
{
	my $self = shift;

	my $lfnState = $self->_lfnState();
	foreach my $lfn ( sort keys %$lfnState )
	{
		print $self->debugStringForLFN( $lfn,1)."\n";
	}
}

sub debugStringForLFN
{
	my $self= shift;
	my $lfn = shift;
	my $pathmode = shift;

	my $lfnState = $self->_lfnState();
	my ( $original, $current, $final ) = @{$lfnState->{$lfn}};

	if( $pathmode )
	{
	$original = $original->lfn() if ref $original;
	$current = $current->lfn() if ref $current;
	$final = $final->lfn() if ref $final;
}
else
{
	$original = $original->debugID() if ref $original;

	$current = "<ZEROLEN>" if $current == $ZERO_LEN_FILE;
	$current = $current->debugID() if ref $current;

	$final = $final->debugID() if ref $final;
}

	$original ||= "<none>";
	$current  ||= "<none>";
	$final    ||= "<none>";



	# return "$original\t$current\t$final\t$lfn";
	return sprintf( "%-35s %-35s %-35s %s", $original, $current, $final, $lfn );
}


sub createClearanceMoves
{
	my $self = shift;

	my $lfnState = $self->_lfnState();
	foreach my $lfn ( sort keys %$lfnState )
	{
		my ( $original, $current, $final ) = @{$lfnState->{$lfn}};

		print $self->debugStringForLFN( $lfn )."\n";
		
		if( defined $current and defined $final and !$current->isDuplicateOf($final) )
		{		
			my $orphanLFN = $self->generateOrphanLFN( $current );
			print "Clearance $lfn -> $orphanLFN \n";

			my $orphan = $self->moveLFN( $lfn, $orphanLFN );

			#print "   Current = ".$current->makeDebugString()."\n";
			#print "   Orphan = ".$orphan->makeDebugString()."\n";

			my $ogs = $self->orphanGS();
			# print "OGS = $ogs\n";
			$ogs->addGhost( $current );
		}
	}
}

# operation to create a zero length file. 

sub touchLFN
{
	my $self = shift;
	my $to = shift;

	# largely unimplemented now. Used to touch zero length files. 

	$self->addWorklist( -action=>'TOUCH', -destination=>$to, -debug=>"X" );
	my $o = $self->_getCurrent($to);
	die if defined $o; 
	$self->_setCurrent($to, $ZERO_LEN_FILE);
}

sub moveLFN
{
	my $self = shift;
	my $from = shift;
	my $to = shift;

	$self->addWorklist( -action=>'MOVE', -source=>$from, -destination=>$to, -debug=>"X" );
	my $g = $self->_getCurrent($from);
	my $o = $self->_getCurrent($to);
	die if defined $o; 
	$self->_setCurrent($to, $g);
	$self->_setCurrent($from, undef );
}

sub copyLFN
{
	my $self = shift;
	my $from = shift;
	my $to = shift;

	$self->addWorklist( -action=>'COPY', -source=>$from, -destination=>$to, -debug=>"X" );
	my $g = $self->_getCurrent($from);
	my $o = $self->_getCurrent($to);
	die if defined $o; 
	$self->_setCurrent($to, $g);
}

sub haulGhostToLFN
{
	my $self = shift;
	my $g = shift;
	my $to = shift;

	my $from = $g->lfn();

	$self->addWorklist( -action=>'HAUL', -source=>$from, -destination=>$to, -debug=>"X" );
	my $o = $self->_getCurrent($to);
	die if defined $o; 
	$self->_setCurrent($to, $g);
}

sub obtainCurrentStateAsGS
{
	my $self = shift;

	my $gs = GhostStore->new();

	my $lfnState = $self->_lfnState();

	# current states may have LFNs that appear more than once 
	# say a copy, or somesuch. Ghoststores don't like that.

	my %seen;

	foreach my $lfn ( sort keys %$lfnState )
	{
		my ( $original, $current, $final ) = @{$lfnState->{$lfn}};
		next if not defined $current; 
		next if $current == $ZERO_LEN_FILE;
		next if $seen{$current->lfn()}++;
		$gs->addGhost( $current );
	}

	return $gs;
}


sub handlePillageFromGS
{
	my $self = shift;
	my $gs = shift;

	print "My GS = $gs\n";
	#$gs->printDebugShort();
	$gs->printDebugMedium();

	my $lfnState = $self->_lfnState();
	foreach my $lfn ( sort keys %$lfnState )
	{
		my ( $original, $current, $final ) = @{$lfnState->{$lfn}};

		print "HandlePillageGS: GST=".$self->debugStringForLFN( $lfn )."\n";

		## Bug - will keep doing this over and over again, gotta stop it
		# from moving files more than once.

		if( defined $final and !defined $current)
		{
			print "    - Check for pillage!\n";
			if( my $pillage = $gs->findSingleDuplicate($final)  )
			{
				print " - Pillage found..[$pillage]\n";
				my $curLFN = $self->findOneInProgressLFNforGhost( $pillage );
				my $n = $self->moveLFN( $curLFN, $lfn);
			}
		}
	}
}

sub findOneInProgressLFNforGhost
{
	my $self = shift;
	my $g = shift;

	my $lfnState = $self->_lfnState();
	foreach my $lfn (  keys %$lfnState )
	{
		CODEPATH( "Horrors - o(n^2) operation!");
		warn "Probably doesn't work anymore..";
		return $lfn if $self->_getCurrent( $lfn ) == $g;
	}

	return undef; 
}

sub handleLocalCopyFromGS
{
	my $self = shift;
	my $gs = shift;

	#print "My GS = $gs\n";
	#$gs->printDebugShort();
	#$gs->printDebugMedium();

	my $lfnState = $self->_lfnState();
	foreach my $lfn ( sort keys %$lfnState )
	{
		my ( $original, $current, $final ) = @{$lfnState->{$lfn}};

		print "handleLocalCopyFromGS: GST=".$self->debugStringForLFN( $lfn )."\n";

		if( defined $final and !defined $current)
		{
			print "    - Check for localcopy!\n";
			if( my $hit = $gs->findSingleDuplicateIncludingSelf($final)  )
			{
				print " - Localcopy found..[$hit]\n";
				my $curLFN = $self->findOneInProgressLFNforGhost( $hit );
				# my $n = $self->copyGhostToLFN( $hit, $final->lfn());

				my $n = $self->copyLFN( $curLFN, $lfn);

			}
		}
	}
}


sub verifyCorrectness
{
	my $self = shift;

	my $lfnState = $self->_lfnState();

	foreach my $lfn ( sort keys %$lfnState )
	{
		my ( $original, $current, $final ) = @{$lfnState->{$lfn}};

		print "Verify: GST=".$self->debugStringForLFN( $lfn )."\n";

		if( $current == $ZERO_LEN_FILE )
		{
			die unless $final->getSize() == 0;
		}

		if( defined $final and !defined $current)
		{
			die "Position not defined: $lfn";
		}
		if( defined $final && $final->getSize() > 0 )
		{
			die "Hash mismatch @ $lfn"  unless $final->isDuplicateOf($current);
		}
	}

}


sub handleZeroLengthFiles
{

	my $self = shift;
	my $lfnState = $self->_lfnState();
	foreach my $lfn ( sort keys %$lfnState )
	{
		my ( $original, $current, $final ) = @{$lfnState->{$lfn}};

		print "handleZero: GST=".$self->debugStringForLFN( $lfn )."\n";

		if( defined $final and !defined $current)
		{
			if( $final->getSize() == 0 )
			{
				$self->touchLFN( $lfn );
			}
		}
	}
}


# Looks for items in the passed in ghost-store as a source for the hash
# information needed at the final destination and generates
# haul records to copy those in. 

sub handleLongHaulCopyFromGS
{
	my $self = shift;
	my $gs = shift;

	#print "My GS = $gs\n";
	#$gs->printDebugShort();
	#$gs->printDebugMedium();

	my $transferGS = GhostStore->new();

	my $lfnState = $self->_lfnState();
	foreach my $lfn ( sort keys %$lfnState )
	{
		my ( $original, $current, $final ) = @{$lfnState->{$lfn}};

		print "handleLongHaulCopyFromGS: GST=".$self->debugStringForLFN( $lfn )."\n";

		if( defined $final and !defined $current)
		{
			print "    - Check for haul [$lfn]!\n";

			if( my $alreadyTransfered = $transferGS->findSingleDuplicateIncludingSelf( $final ))
			{
				print "    - Already transfered [$lfn]!\n";
				next;
			}

			if( my $hit = $gs->findSingleDuplicateIncludingSelf($final)  )
			{
				print " - Haul found..[$hit]\n";

				my $n = $self->haulGhostToLFN( $hit, $lfn);
				$transferGS->addGhost($n);

			}
		}
	}
}


sub addWorklist
{
	my $self = shift;
	my %hash = @_;

	my $action = $hash{-action};

	my $S = defined $hash{-source} ? $hash{-source} : "undef";
	my $D = defined $hash{-destination} ? $hash{-destination} : "undef";

	print "Adding Worklist: $action [$S] [$D]\n";

	# foreach my $k (sort keys %hash )
	# {
	# 	print "     $k => $hash{$k}\n";
	# }

	push @{$self->{WL}}, \%hash;
}


sub execute
{
	my $self = shift;
	my $worklist = $self->{WL};

	my $numOperations = @$worklist;
	my $i = 0;

	my $tk = TruthKeeper::get();

	foreach my $hash (@$worklist)
	{
		print "------------------ Operation $i / $numOperations\n";


		my $action = $hash->{-action};

		my $S = defined $hash->{-source} ? $hash->{-source} : undef;
		my $D = defined $hash->{-destination} ? $hash->{-destination} : undef;

		my $SG = $tk->obtainGhostForLFN( $S ) if defined $S;
		my $DG = $tk->obtainGhostForLFN( $D ) if defined $D;

		my $Sdebug = defined $hash->{-source} ? $hash->{-source} : "undef";
		my $Ddebug = defined $hash->{-destination} ? $hash->{-destination} : "undef";


		debug( "Source = " . $SG->makeDebugString() . "\n" ) if ref $Sdebug;
		debug( "Dest   = " . $DG->makeDebugString() . "\n" ) if ref $Ddebug;


		print "Action->[$action] source:[$Sdebug] destination:[$Ddebug]\n";

		if( $action eq 'HAUL' )
		{
			print "Source: " . $SG->quickDebugString() . "\n";
			print "Dest  : " . $DG->quickDebugString() . "\n";
			$DG->store( $SG );
		}
		elsif( $action eq 'COPY' )
		{
			print "Source: " . $SG->quickDebugString() . "\n";
			print "Dest  : " . $DG->quickDebugString() . "\n";
			$DG->store( $SG );
		}
		elsif( $action eq 'MOVE' )
		{
			print "Source: " . $SG->quickDebugString() . "\n";
			print "Dest  : " . $DG->quickDebugString() . "\n";
			$SG->moveGhost( $DG );
		}
		elsif( $action eq 'TOUCH' )
		{
			$DG->touchSmallfile();
		}
		else
		{
			die "Unacceptable action=$action"
		}




		$i++;
	}
}


sub printWorklist
{
	my $self = shift;
	my $worklist = $self->{WL};
	foreach my $hash (@$worklist)
	{
		my $action = $hash->{-action};

		my $S = defined $hash->{-source} ? $hash->{-source} : "undef";
		my $D = defined $hash->{-destination} ? $hash->{-destination} : "undef";

		print "$action $S $D\n";
	}
}

package FilesystemExplorer::Volume;

# use File::Basename;
# use File::Spec; 
# use File::Spec::Functions;
# use File::Path; 
use base qw(Class::Accessor);
FilesystemExplorer::ObjectStore->mk_accessors( qw( _rootDir _isInitialized ) );

sub debug($)
{
	my $a = shift;
	main::debug( "fse/OJX: " . $a );
}

sub new
{
	my $class = shift;
	my $root = shift;
	my $self = $class->SUPER::new();

	die unless defined $root; 
	$self->_rootDir( $root );
	$self->_isInitialized( 0 );

	return $self;
}

sub finalize
{
	my $self = shift;

	# in practice, this is not always called. It may not have entered the FSE
	# cache. i'm not sure yet if that is an issue or not.

	debug "Shutdown $self.. - no action taken." if $fseOjxDebug;
}

sub initialize
{
	my $self = shift;

	$self->{ROOTDIR} = $self->_rootDir();
	die unless -w $self->{ROOTDIR};

	$self->_isInitialized(1);
}

sub setUpRepository
{
	my $self = shift;

	$self->internalMkDir( catfile( $self->_rootDir() ));
	$self->internalMkDir( catfile( $self->_rootDir(), 'ptr' ));
	$self->internalMkDir( catfile( $self->_rootDir(), 'obj' ));

	$self->initialize();
}


package FilesystemExplorer::ObjectStore;

use File::Basename;
use File::Spec; 
use File::Spec::Functions;
use File::Path; 
use base qw(Class::Accessor);
FilesystemExplorer::ObjectStore->mk_accessors( qw( _rootDir _isInitialized ) );

sub debug($)
{
	my $a = shift;
	main::debug( "fse/OJX: " . $a );
}

sub new
{
	my $class = shift;
	my $root = shift;
	my $self = $class->SUPER::new();

	die unless defined $root; 
	$self->_rootDir( $root );
	$self->_isInitialized( 0 );

	return $self;
}

sub finalize
{
	my $self = shift;

	# in practice, this is not always called. It may not have entered the FSE
	# cache. i'm not sure yet if that is an issue or not.

	debug "Shutdown $self.. - no action taken." if $fseOjxDebug;
}

sub initialize
{
	my $self = shift;

	$self->{ROOTDIR} = $self->_rootDir();
	$self->{PTR_DIR} = catfile( $self->_rootDir(), 'ptr' );
	$self->{OBJ_DIR} = catfile( $self->_rootDir(), 'obj' );

	die unless -w $self->{ROOTDIR};
	die unless -w $self->{PTR_DIR};
	die unless -w $self->{OBJ_DIR};

	$self->_isInitialized(1);
}

sub setUpRepository
{
	my $self = shift;

	$self->internalMkDir( catfile( $self->_rootDir() ));
	$self->internalMkDir( catfile( $self->_rootDir(), 'ptr' ));
	$self->internalMkDir( catfile( $self->_rootDir(), 'obj' ));

	$self->initialize();
}

sub internalMkDir
{
	my $self = shift;
	my $p = shift;

	main::globalMkPath( $p );

	# main::mkdirs( File::Spec->catfile( $self->{ROOTDIR}, "foo" ));
}

sub setPointer
{
	my $self = shift;
	my $name = shift;
	my $value = shift;

	die unless $self->_isInitialized();
	die "Pointers cannot be empty strings" if length($name) < 1;
	die "Pointers cannot have trailing slashes" if $name =~ /\/$/;

	debug( "setPtr: [$name]=>[$value]") if $fseOjxDebug;

	$self->{PTR}->{$name} = $value;

	my $targetPath = catfile( $self->{PTR_DIR}, ($name . ".ptr" ));

	die "setPointer tried to replace directory with a file" if( -d $targetPath );

	# Super schitzophrenic - shou;dn't this ALL be done via the ghost API?
	my $dirPath = dirname $targetPath;
	debug( "Checking readibility of [$dirPath]");
	if( ! -e $dirPath )
	{
		$self->internalMkDir( $dirPath );
	}

	open FILE, ">$targetPath" or die "Could not open [$targetPath] for pointer: $!";
	print FILE $value;
	close FILE,
}

sub getPointer
{
	my $self = shift;
	my $name = shift;
	
	die unless $self->_isInitialized();
	die "Pointers cannot have trailing slashes" if $name =~ /\/$/;
	die "Pointers cannot be empty strings" if length($name) < 1;

	my $targetPath = catfile( $self->{PTR_DIR}, $name );

	if( exists $self->{PTR}->{$name})
	{
		my $value = $self->{PTR}->{$name};
		debug( "getPtr: [$name]=>[$value] (cache)") if $fseOjxDebug;
		return $value;
	}

	if( ! -e $targetPath )
	{
		my $value = undef; 
		debug( "getPtr: [$name]=>[undef] (stat)") if $fseOjxDebug;
		return $value;
	}

	local $/ = undef;
	local *FILE;
	open FILE, "<$targetPath" or die "Could not open [$targetPath] for pointer: $!";
	my $value = <FILE>;
	close FILE,

	$self->{PTR}->{$name} = $value;
	debug( "getPtr: [$name]=>[$value] (disk)") if $fseOjxDebug;

	return $value; 
}


# Provides a universal name for the LFN that should be completely invarient to
# CWD, time and space, etc. Basically, this ghost should be the same no matter
# where in the cluster of machines the user is running it.
# 
# CORE

sub getAbsoluteLFNForGhost
{
	my $self = shift;
	my $g = shift;

	# By design, object store references are already universal

	return $g->lfn();
}



# One of the universal methods. It basically says make a copy of the things
# I'm pointing to and gives you the name of the place to store it. If there is
# something already in that position, leaves it up to each FSE what to do with it.

sub store
{
	my $self = shift;
	my $source = shift;
	my $target = shift;

	die "file to store does not exist" unless $source->exists();
	die "store only works for single files" unless $source->isSingleFile();

	# my $hardFilename = $source->getHardFile();

	my $hash = $source->getFullHash();

	my $targetPath = $self->makeContainingDirForHash( $hash );
	my $targetLFN = $self->makeFullPathForHash( $hash );

	# Super schitzophrenic - shou;dn't this ALL be done via the ghost API?
	$self->internalMkDir( $targetPath );

	my $tk = TruthKeeper::get();
	my $targetGhost = $tk->obtainGhostForLFN($targetLFN);
	$targetGhost->store( $source );

	my $targetUserPath = $target->getPath();

	if( length($targetUserPath) > 0 )
	{
		my $pointerName = catfile( "adhoc", $targetUserPath );
		$self->setPointer( $pointerName, $hash );
	}
}

sub makeContainingDirForHash
{
	my $self = shift;
	my $hash = shift;

	my $justHash = main::extractHashComponents( $hash )->[2];
	my $targetPath = catfile( $self->{OBJ_DIR}, $justHash );

	return $targetPath;
}

sub makeFullPathForHash
{
	my $self = shift;
	my $hash = shift;

	my $justHash = main::extractHashComponents( $hash )->[2];
	my $targetPath = $self->makeContainingDirForHash( $hash ); 

	my $finalPath = catfile( $targetPath, $justHash );
	my $targetLFN = main::assembleLFN( "fs", "root", $finalPath);

	return $targetLFN;
}

sub absorbScalar
{
	my $self = shift;
	my $buffer = shift;

	my $hash = "";

	die;


	my $targetPath = $self->makeContainingDirForHash($hash);
	my $targetLFN = $self->makeFullPathForHash($hash);


}

# A universal method that says "take the things I pointed to, and make sure
# you've stored it somewhere". In this form, you're not allowed to say where
# it gets stored or how, just that it shpuld be there.

sub absorb 
{
	my $self = shift;
	my $source = shift;
	die "absorb only works for single files" unless $source->isSingleFile();

	die "absorb not implemented for this FSE type.";
}


# Core 
#
# Forces the ghost, if it exists, to return an absolute file on the local
# filesystem. This should ALWAYS return a local path (can be a temp file.) the
# caller must promise to not tamper with this in any way other than a read.

sub getReadonlyHardFile
{
	my $self = shift;
	my $g = shift;

	return $self->getHardFilePathForGhost( $g );
}

# give a OBJ: style ghost and get a ghost pointing to the underlying file

sub getHardFileGhost
{
	my $self = shift;
	my $g = shift;

	my $tk = TruthKeeper::get();
	my $targetLFN = $self->getHardFileFQLFNforGhost( $g );
	my $targetGhost = $tk->obtainGhostForLFN($targetLFN);
	return $targetGhost; 
}


# Give a OBJ: type ghost and get the hard file local filename corresponding to it

sub getHardFileFQLFNforGhost
{
	my $self = shift;
	my $g = shift;


	my $finalPath = $self->getHardFilePathForGhost( $g );
	my $targetLFN = main::assembleLFN( "fs", "root", $finalPath);

	return $targetLFN;
}

sub getHardFilePathForGhost
{
	my $self = shift;
	my $g = shift;

	my $path = $g->getPath();
	my $pointerName = catfile( "adhoc", $path ) . ".ptr";
	my $hash = $self->getPointer( $pointerName );
	my $justHash = main::extractHashComponents( $hash )->[2];
	my $targetPath = catfile( $self->{OBJ_DIR}, $justHash );
	my $finalPath = catfile( $targetPath, $justHash );

	return $finalPath; 
}


sub getStatSourceVerify
{
	my $self = shift;
	my $g = shift;
	my $time = shift;
	
	my $hardfile = $self->getHardFileGhost( $g );
	return( $hardfile->getStatSourceVerify( $time ) );
}


sub getFullHashSourceVerify
{
	my $self = shift;
	my $g = shift;
	my $time = shift;
	
	my $hardfile = $self->getHardFileGhost( $g );
	return( $hardfile->getFullHashSourceVerify( $time ) );
}



package FilesystemExplorer::Snapshot;

use File::Basename;
use base qw(Class::Accessor);
FilesystemExplorer::Snapshot->mk_accessors( qw( dirty rootGhost rootGhostStore isFinalized deNovo) );


sub debug($)
{
	my $a = shift;
	main::debug( "FSE/ss: " . $a );
}

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();

	return $self;
}


sub getAbsoluteLFNForGhost
{
	my $self = shift;
	my $g = shift;

	# The correct implementation would be to get the unique hash for this
	# snapshot, whatever it is in the "root" component of the LFN. That unique
	# hash code may change over time, so we are going to impose a rule that
	# you can  only ask this kind of question if the snapshot is not dirty.
	# Our callers will have to tolerate this

	die "Absolute LFNs do not exist for snapshots while in a dirty state" if $self->dirty();

	return main::rewriteLFNreplaceRoot( $g->lfn(), "HACKED_HASH_GOES_HERE");
}


sub absorb
{
	my $self = shift;
	my $g = shift;

	my $DID = $g->debugID();

	debug "Storing ghost $DID" if $gsDebug;

	# FOR NOW, we'll assume that snapshots are pretty immuteable, 
	# but clearly there is no reason for them to be so

	# die if defined $self->rootGhostStore();


	my( $handler, $root, $path ) = main::parseFQLFN( $g->lfn() );

	$handler = "snap";
	$root = "root";

	my $newLFN = main::assembleLFN( $handler, $root, $path );

	my $copy = $g->cloneWithLFN( $newLFN );
	# TODO not clear if this is a boundary violation SOC issue
	$copy->_immutable(1);



	# this is definitely a truthy thing
	# TODO boundary issue, what if user's new name for the snapshot overwrites an existing 
	# snapshot name??? what is "correct"
	TruthKeeper::get()->registerTruthyGhost( $copy );

	$self->rootGhostStore()->addGhost( $copy );

	return $copy; 
}


sub finalize
{
	my $self = shift;

	return if $self->isFinalized();

	my $store = $self->rootGhostStore();

	$self->loadRootIfNeeded();

	# The rule for now is a snapshot FSE is not changed after its opened If
	# you want to do that, you'd clone it to a new object So the FSE is either
	# in a read state (deNovo = false) or in a making a new thing state
	# (deNovo = TRUE).

	if( not $self->deNovo() )
	{
		debug "Snapshot is not new, no finalization performed." if $fseSnapshotDebug;
	}
	else
	{
		# TODO HACK
		# technically should delegate to the FSE controller
		$store->writeSnapshotToDisk( $self->rootGhost()->getRoot() );

		foreach my $g ( $store->getAllGhosts() )
		{
			$g->dirty(0);
		}

		$self->dirty(0);
	}

	$self->isFinalized(1);
}



# I'm still working out the right meaning exactly, but when you ask a FSE for
# a ghost like this, I think it's supposed to mean you want one that is fully
# truth enabled, not just any crappy ghost. we may need to rename this
# function once we know how the semantic should be honored

sub findGhostForLFN
{
	my $self = shift;
	my $lfn = shift;

	$self->loadRootIfNeeded();

	return $self->rootGhostStore()->findGhostForLFN( $lfn ); 

}

sub loadRootIfNeeded
{
	my $self = shift;

	my $rgs = $self->rootGhostStore();

	return $rgs if ref $rgs;

	$rgs = GhostStore->new();
	$self->rootGhostStore( $rgs );

	# Hack, probably should handle this with a FS ghost
	if( -r $self->rootGhost()->getRoot()  )
	{
		$rgs->slurpSnapshot( $self->rootGhost()->getRoot(), $self->rootGhost()->getRoot() );
		# dirty flag is clean because we are consistent with source backed file
		$self->dirty(0);
		$self->deNovo(0);
	}
	else
	{
		warn "In that unusual case where we don't load anything";
		# dirty flag is TRUE because we are in an uncommitted state
		$self->dirty(1);
		$self->deNovo(1);
	}

#	debug "Incorporating snapshot truth\n" if $tkdebug;

	TruthKeeper::get()->incorporateGhostStore( $rgs );

	return $rgs;
}

sub getFullHashSourceVerify
{
	my $self = shift;
	my $lfn = shift;

	die "getFullHashSourceVerify - Snapshots are immutable - should not have reached this point\n";

	# my $rgs = $self->loadRootIfNeeded();

	# return ($size, $mtime, $mode);
}

sub getStatSourceVerify
{
	my $self = shift;
	my $lfn = shift;

	die "getStatSourceVerify - Snapshots are immutable - should not have reached this point\n";


	# my $rgs = $self->loadRootIfNeeded();

	# my ($size, $mtime, $mode);

	# return ($size, $mtime, $mode);
}


##########
# The FSE class handles low level access and coherency for a particular
# domain of listed files. This could be a real file system or a snapshot
# or even a remote filesystem or S3 type thing.
# 
# I think this is the right definition for the class: 
#
# It provides the ability to iterate over the filesystem in an organized way.
# Everything that hits a primary resource should go here
# FSE is mainly called by the ghost API
# 
# Verbs i know it has to support
#
# - iteration
# - findDuplicates();


package FilesystemExplorer::FS;

use Time::HiRes qw( CLOCK_REALTIME gettimeofday tv_interval);
use File::Basename;
use File::Copy;
use base qw(Class::Accessor);
FilesystemExplorer::FS->mk_accessors( qw(topLevelLFNs sizeToFNs) );

# Return new FSE
# CORE - any FSE must implement


sub debug($)
{
	my $a = shift;
	main::debug( "FSE/fs: " . $a );
}

sub CODEPATH($)
{	
	my $p = shift; 
	main::CODEPATH( "FSE/fs: $p" );
}

sub finalize
{
	my $self = shift;

	# in practice, this is not always called. It may not have entered the FSE
	# cache. i'm not sure yet if that is an issue or not.

	debug "Shutdown $self.. - no action taken." if $fseDebug;
}

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();

	$self->sizeToFNs( undef );

	return $self;
}

# CORE

sub getAbsoluteLFNForGhost
{
	my $self = shift;
	my $g = shift;

	# $g->printDebug();

	return main::rewriteLFNPathAbsolute($g->lfn());
}


# for directories, returns the parent directory, or undef if there is none.

sub getParentLFN
{
	my $self = shift;
	my $g = shift;

	my $lfn = $g->lfn();
	my ($handler, $root, $path ) = main::parseFQLFN($lfn);

	my $absPath = Cwd::realpath( $path  );

	print "Getting parent of AFN: $absPath\n";

	if( $absPath eq File::Spec->rootdir() )
	{
		return undef; 
	}

	return main::rewriteLFNPathParent( $g->lfn() );
	

}


# for single files, returns the directory
sub getContainingDirLFN
{
	my $self = shift;
	my $g = shift;

	my $c = main::rewriteLFNPathDirname( $g->lfn() );

	return $c;
}




# CORE

sub getFullHashSourceVerify
{
	my $self = shift;
	my $g = shift;
	my $time = shift; 

	my $path = $g->getPath();

	print "*** FULLHASH: $path\n" if $ioDebug;

	# TODO: examine use of stat
	$main::run_bytes_fullread += -s $path;

	my $START_GTOD = [gettimeofday];

	my $sha = Digest::SHA->new(1);
	$sha->addfile( $path );
	my $hexdigest = $sha->hexdigest();

	$main::run_files_fullread++;

	$main::run_time_fullread += tv_interval( $START_GTOD );

	return( "SHA1/FULL/$hexdigest");
}

# CORE

sub getStatSourceVerify
{
	my $self = shift;
	my $g = shift;
	my $time = shift;


	my $path = $g->getPath();

	print "*** STAT: $path\n"  if $ioDebug;

	$main::run_files_stat++;

	my @statfields = stat($path);

	if( @statfields == 0 )
	{
		my $errcode = $! + 0;
		print "   stat-error - $! = $errcode\n" if $ioDebug;
		return (undef, undef, main::statModeGen_error($errcode));
	}

	# die "Ghost [$path] failed stat - probably doesn't exist: $! ($@)" ;
	my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = @statfields; 
	
	my $statStruct = new StatStruct;
	$statStruct->loadFromPOSIXstat( \@statfields );

	return ($size, $mtime, $mode, $statStruct );
}



# Return LFNs of immediate children. This is for source verification purposes.
# CORE - any FSE must implement

sub getImmediateChildren
{
	my $self = shift;
	my $parent = shift;

	my $dir = $parent->getPath();

	print "*** Scandir [$dir]\n" if $ioDebug; 

	print "FSE:ScanDIR into dir:[$dir]\n" if $fseDebug;

	#$dir =~ s/\/+$//;

	opendir DIR, $dir or die "cannot descend into [$dir] for getImmediateChildren: $! $@";

	$main::readdir_invokes++;

	# drop . and .., sort directory
	my @files = map { "fs:root:" . $_ }
	    map {  main::canonize( File::Spec->catfile( $dir, $_ ) ) } 
		grep { !/^\.{1,2}$/ } 
		grep { !main::isHardIgnore( $_ ) } 
		sort { $a cmp $b } 
		readdir DIR;

	$main::readdir_entries += @files;

	print( "FSE:ScanDIR Returned: [", (join '],[', @files ), "]\n" ) if $fseDebug;

	close DIR;

	return \@files;
}


# Generate a "smallfile" from a ghost. Currently used for zero length files,
# which cannot be content-addressed but the user often wants to keep around
# anyway. Right now focuses on zero-length, but the intention is that this
# would allow ghost's themselves to contain small amounts of file content,
# which could save us some reads and writes.

sub touchSmallfile
{
	my $self = shift;
	my $target = shift;

	my $destPath = $target->getPath();
	my $dirname = File::Basename::dirname( $destPath );


	print "touch() - TOUCH - [$destPath]\n";

	main::globalMkPath( $dirname );

	open FILE, ">$destPath" or die "cannot open $destPath to make a smallfile" ;
	close FILE; 
}





# 
#
# CORE
# 
# One of the universal FSE methods. It basically says make a copy of the things
# I'm pointing to and gives you the name of the place to store it. If there is
# something already in that position, leaves it up to each FSE what to do with it.

# BE CAREFUL: We are always the FSE handler for the TARGET, not the SOURCE, so
# our first job is to force the the SOURCE to something we're prepared to
# read.

sub store
{
	my $self = shift;
	my $sourceGhost = shift;
	my $target = shift;

	die "file to store does not exist" unless $sourceGhost->exists();
	die "store only works for single files" unless $sourceGhost->isSingleFile();

	# this extra overhead forces the file to be a filesystem object and
	# ensures that we are only working with a ghost that is authoritative.

	my $hardFilename = $sourceGhost->getReadonlyHardFile();
	my $sourceFileLFN = main::assembleLFN( "fs", "root", $hardFilename);
	my $tk = TruthKeeper::get();
	my $sourceFileGhost = $tk->obtainGhostForLFN($sourceFileLFN);

	my $srcPath = $sourceFileGhost->getPath();
	my $destPath = $target->getPath();
	my $dirname = File::Basename::dirname( $destPath );


	print "store() - COPY - [$srcPath]->[$destPath]\n";

	main::globalMkPath( $dirname );


	my $finalTarget; 

	if( $target->exists( time() ) )
	{
		if( $target->isDuplicateOf($sourceGhost) )
		{
			print "store(): Source and destination are identical, no action.\n";
			CODEPATH( "store.identical");
			return $target; 
		}
		else
		{
			print "store(): destination exists, generating new location.\n";
			my $newLocation = $target->generateAlternativeLocation( 'storeOperation' );
			CODEPATH( "store.relocate");

			# should be a move, not a copy, but that means we have to work out move semantics
			$newLocation->store($target);
			$finalTarget = $target;
		}
	}
	else
	{
		$finalTarget = $target;
	}

	my $finalPath = $finalTarget->getPath();

	#print "store(): Invoking full copy [$srcPath]->[$finalPath]\n";

	my $sourceSize = $sourceGhost->getSize();

	 $main::run_files_copied++;
	 $main::run_bytes_copied += $sourceSize;

	print "*** COPY [$srcPath]->[$finalPath]\n" if $ioDebug;

	my $r = copy( $srcPath, $finalPath );

	if( !$r )
	{
		die "Copy operation failed - [$srcPath]->[$finalPath]: err: $!";
	}

	$finalTarget->learnIsACopyOfGhost( $sourceGhost );

	# Perform a quick verification that the file sizes match. Not strictly
	# needed. The caller can force more verification if it wants.

	if( $finalTarget->getSize() != $sourceSize )
	{
		die "Assert: My copy succeeded but the getSize() no longer matches - what gives?";
	}

	return $finalTarget; 

	# die "Copy not implemented";

}


# 
#
# CORE  
# 
# One of the universal FSE methods. When this is invoked, we are always
# the FSE manager for the SOURCE. (This is the opposite of the case of a copy.)
# This should die if the move cannot be performed in the way that preserves everything. 

sub moveGhost
{
	my $self = shift;
	my $source = shift;
	my $target = shift;


	die "file to move does not exist" unless $source->exists();

	die "move only works for single files" unless $source->isSingleFile();
	die "move only works for single files" unless $target->isSingleFile() or !$target->exists();

	my $srcPath = $source->getPath();
	my $destPath = $target->getPath();

	die unless $source->getHandler() eq 'fs';
	die unless $target->getHandler() eq 'fs';

	print "move() - MOVE - [$srcPath]->[$destPath]\n";

	die "move() - already a file present at target location!" if $target->exists( time() );

	my $originalSize = $source->getSize( time() );

	$main::run_files_moved++;
	my $r = move( $srcPath, $destPath );

	if( !$r )
	{
		die "Copy operation failed - [$srcPath]->[$destPath]: err: $!";
	}

	my $effectiveTime = time() ;
	$target->learnIsACopyOfGhost( $source );

	$source->learnContentsChanged( $effectiveTime );

	# Perform a quick verification that the file sizes match. Not strictly
	# needed. The caller can force more verification if it wants.

	my $newSize = $target->getSize( $effectiveTime );

	if( $newSize != $originalSize  )
	{
		die "Assert: Move succeeded but the getSize() no longer matches - what gives? Orig=$originalSize New=$newSize";
	}


	return $target;
}


sub forDuplicatesMap
{
	my $self = shift;
	my $target = shift;
	my $fitFunction = shift;

	my $hash = $target->getFullHash();
	my $gdb = GhostDatabase->getCore();

	my $afns = $gdb->findAFNsForHash($hash);

	my $tk = TruthKeeper::get();
	my @g = map { $tk->obtainGhostForLFN( $_ ); } @$afns;
	my @result;

	foreach my $g (@g)
	{
		my $r = $target->isDuplicateOf( $g );

		my $dstr = $g->quickDebugString();
		my $dstr2 = $target->quickDebugString();
		debug "findDuplicatesCustomSearch=($r) Candidate: $dstr\n"; 
		debug "findDuplicatesCustomSearch=($r) Target:    $dstr2\n"; 

		if( $r )
		{
			my $x = $fitFunction->($g, $target);
			push @result, $x unless $x == $CODE_SKIP_DUPLICATE;
		}
		else
		{
			warn "XXXXX AFN database out of date!";
			print "I'm looking for hash:$hash (on $dstr2)\n";
			print "I retrieved target (on $dstr)\n";
			print "However, isDuplicateOf() returned FALSE\n";
		}
		
	}

	return @result;
}


sub findDuplicateUnderTree
{
	my $self = shift;
	my $topLevel = shift;
	my $target = shift;
	my $just_one = shift || 0;

	# print "enter\n";

	my $hash = $target->getFullHash();
	my $gdb = GhostDatabase->getCore();

	my $afns = $gdb->findAFNsbyHashAndPrefix($hash,$topLevel->absoluteLFN());

	my $tk = TruthKeeper::get();
	my @g = map { $tk->obtainGhostForLFN( $_ ); } @$afns;

	# print "g=@$afns\n";

	my @result;

	foreach my $g (@g)
	{
		my $r = $target->isDuplicateOf( $g );

		my $dstr = $g->quickDebugString();
		# debug "findDuplicateUnderTree=($r) for $dstr\n"; 

		return $g if( $just_one );
		push @result, $g; 
	}

	return undef if( $just_one && @result == 0 );

	return \@result; 
}





# Returns a new available location for a file that is writeable and guarenteed
# to not be re-used

local %FilesystemExplorer::FS::altLocationGuarentee;

sub generateAlternativeLocation
{
	my $self = shift;
	my $g = shift;
	my $strategy = shift; 

	$g->getPath(); 
	my $tk = TruthKeeper::get();

	my $newOrphanNameFound = 0;
	my $scramble = 0;
	my $finalNewOrphanLFN = 0; 

	my $datestr = POSIX::strftime( "%Y%m%d", localtime() );

	while( not $newOrphanNameFound )
	{
		# Calculate a new name for this file
		my $orphanNewPathName = $g->getPath() . ".gsfmoved-$datestr";
		$orphanNewPathName .= "-$scramble" if $scramble > 0;
		my $orphanNewLFN = main::assembleLFN( $g->getHandler() , $g->getRoot(), $orphanNewPathName );
		my $orphanGhost = $tk->obtainGhostForLFN( $orphanNewLFN );
		print "       - testing orphan: $orphanNewLFN\n";
		$scramble++;
		if( $orphanGhost->exists() )
		{
			CODEPATH( "Rare - orphanNewLFN - needed additional clearance check" );
			next;
		}
		if( $FilesystemExplorer::FS::altLocationGuarentee{orphanNewLFN} )
		{
			CODEPATH( "Rare - orphanNewLFN - guarnetee override" );
			next; 
		}

		$FilesystemExplorer::FS::altLocationGuarentee{$orphanNewLFN} = 1; 
		return $orphanGhost;
	}

	die "Logic error.";
}


# Forces the ghost, if it exists, to return an absolute file on the local
# filesystem. This should ALWAYS return a local path (can be a temp file.) the
# caller must promise to not tamper with this in any way other than a read.

sub getReadonlyHardFile
{
	my $self = shift;
	my $thing = shift; 

	# Implementation is super easy - just get my path and be done!

	die unless $thing->exists();

	return $thing->getPath();
	
}





package FSEFactory;

# is container the right term for this?

my $fseFactoryDebug = 0;
my %fseForHandlerRoot;

sub debug($)
{
	my $a = shift;
	main::debug( "FSE-factory: " . $a );
}

sub shutdown
{
	my $self = shift;

	# TODO - odd exception if the local FSE handler is not here, right?

	debug( "-- Shutting down FSE Factory") if $fseFactoryDebug;

	foreach my $key ( keys %fseForHandlerRoot )
	{
		my $fse = $fseForHandlerRoot{$key};
		debug( "Sending finalization call to $fse") if $fseFactoryDebug;
		$fse->finalize();
	}
}



# This is the core function that dispatches out the FSE handler for the
# particular path. All handlers are ultimately registered here.

sub getFSEHandlerForGhost
{
	my $class = shift;
	my $g = shift;
	my $lfn = $g->lfn();

	# print "$lfn**\n";

	my $r = undef;

	my ($handler, $root, $path ) = main::parseFQLFN($lfn);

	my $key = $handler . ":" . $root;

	if( $handler eq 'snap' )
	{
		my $class = "FilesystemExplorer::Snapshot";

		## TODO - break this out into a cleaner function

		if( exists $fseForHandlerRoot{$key} )
		{
			debug "Found existing handler for $key @ $class"  if $fseFactoryDebug;
			$r = $fseForHandlerRoot{$key};
		}
		else
		{
			debug "Making new handler for $key @ $class"  if $fseFactoryDebug;
			$r = $class->new();
			$r->rootGhost($g);
		}
	}	
	elsif( $handler eq 'fs' )
	{
		die "FS handler for non-root is not supported yet" if $root ne 'root';
		$r = $main::localFileSystemFSE;
	}
	elsif( $handler eq 'obj' )
	{
		die "OBJ handler for non-root is not supported yet" if $root ne 'core';
		$r = $main::coreOjxFSE;
	}
	else
	{
		die "Unrecognized LFN handler: [$lfn] ERROR - Handler [$handler] is unknown.";
	}

	debug "FSEFactory: FSE handler for lfn:[$lfn] --> Class:[$r]" if $fseFactoryDebug;

	$fseForHandlerRoot{$key} = $r;

	return $r; 
}


package TruthKeeper;

use Data::Dumper;
use File::Basename;
use base qw(Class::Accessor);

my $global_tk;

my %ghostForLFN_private;

my %ghostStoreForDescriptorLFN;

sub debug($)
{
	my $a = shift;
	main::debug( "TK: " . $a );
}

sub CODEPATH($)
{	
	my $p = shift; 
	main::CODEPATH( "TK: $p" );
}


# Takes ghosts provided by a command line and  blows out a fully qualified LFN
# and gets the ghosts returns a nice structure of data you'd need for iteration
# on the command line: [provided ARGV, fully qualified ghost name, ghost]

sub makeGhostsFromCommandLine
{
	my $self = shift;
	my @stuff = @_;

	my $gs = GhostStore->newDescending();

	my @stash = ();

	foreach my $lfn (@stuff )
	{
		my $fqlfn = main::fullyQualifyLFN( $lfn );

		debug "Make Ghost Via CommandLine user provided ".
			"lfn:[$lfn]->fqLFN:[$fqlfn] from command line to store\n"
			if $tkdebug;

		my $g = $self->obtainGhostForLFN($fqlfn);
		$gs->addGhost( $g );
		push @stash, [$lfn, $fqlfn, $g ];
	}

	return ($gs, \@stash);
}

sub ghostForLFN
{
	my $self = shift;
	return \%ghostForLFN_private;
}


sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();
	# $self->ghostForLFN( +{} );
	return $self;
}

sub printInternallyTrackedLFN
{
	my $self = shift;
	my $ghostForLFN = $self->ghostForLFN();

	foreach my $g (values %$ghostForLFN )
	{
		debug ("     " 
			 . ($g->dirty() ? "YES" : "NO")
		     . "  "
		 	 . $g->quickDebugString()
		     . "  " );

		 #debug( "          -> ". $g->makeDebugString() );
	}
	return;
}

# Theorietically there should not be too many ghosts that the calling code did
# not flush along the way. However, some of the revocations of directories may
# be stragglers of a sort. Also, if a handler is largely just working with
# files in recursion, it may be hard to track down new information
# accidentally discovered during recursion. But technically, if we're doing
# our job, this cache should be completely clean.

sub flushInternallyTracked
{
	my $self = shift;
	my $ghostForLFN = $self->ghostForLFN();
	my $gdb = GhostDatabase->getCore();
	foreach my $g (values %$ghostForLFN )
	{
		next unless $g->dirty(); 

		my $gd = $g->quickDebugString();
		debug "WARNING: flushed $gd\n";
		$g->flush();
 	}
}


sub flush
{
	my $self = shift;

#	debug Dumper( $self );

	debug "---- Beginning flush ---\n" if $tkflushdebug;

	debug "---- Inventory of all internally tracked ---\n" if $tkflushdebug;

	$self->printInternallyTrackedLFN() if $tkflushdebug;

	# At this point, dirty ghosts in the truthkeeper could be dirty from what
	# they learned from other knowledge sources, or from what they learned on
	# disk. There doesn't seem to be any way to know which things have to be
	# pushed out to remote sources. Right now, the only strategy I'm using for
	# the universal store is to aquire the object, and learn it back,
	# and then do a write if anythign changes.

	debug "---- Internal Tracking Flush ---\n" if $tkflushdebug;

	$self->flushInternallyTracked();


	# debug "---- Ghost Cache Writes ---\n" if $tkflushdebug;

	# $self->flushGhostDescriptorCache();



	debug "---- Verify ---\n" ;#if $tkflushdebug;

	$self->verifyNoDirtyGhostsRemain();
}

sub get
{
	my $class = shift;

	return $global_tk if defined $global_tk;

	$global_tk = new TruthKeeper();

	return $global_tk;
}

sub verifyNoDirtyGhostsRemain
{
	my $self = shift;
	my $ghostForLFN = $self->ghostForLFN();

	my $error = 0;

	foreach my $g (values %$ghostForLFN )
	{
		if( $tkflushdebug )
		{
			debug "   Verifying TK Ghost: " . ($g->dirty() ? "YES" : "NO") . "   " .  $g->quickDebugString();
		}	

		# TODO - unresolved design decision, what do we do with dirty snapshot
		# stuff?

		if($g->dirty())
		{
			if( $g->getHandler() eq 'snap')
			{	
				my $lfn = $g->lfn();
				debug "Wierd straggler case - I haven't figured out yet who, if anyone flushes this type of object.: $lfn";
			}
			elsif( $g->getHandler() eq 'obj')
			{	
				my $lfn = $g->lfn();
				debug "Wierd straggler case - I haven't figured out yet who, if anyone flushes this type of object.: $lfn";
			}

			else
			{
				$error++;
			}
		}
	}

	die "Dirty ghosts remain unflushed!! assert" if $error > 0;
}

sub flushGhostDescriptorCache
{
	my $self = shift;

	foreach my $gslfn ( keys %ghostStoreForDescriptorLFN )
	{
		## my $gs = getGhostStoreForDescriptorFileCoveringFN( $k );

		$self->flushDescriptorToDisk( $gslfn );
	}
}

sub flushDescriptorToDisk
{
	my $self = shift;
	my $lfn = shift; # LFN of the ghoststore

	debug "TK: Flushing ghoststore [$lfn] to disk\n" if $tkdebug;

	if( not exists $ghostStoreForDescriptorLFN{$lfn} )
	{
		die "Internal assert - $lfn not found" if $tkdebug;
	}

	my $gs = $ghostStoreForDescriptorLFN{$lfn};

	$gs->purifyAllGhostsToTK();

	if( $gs->countDirty() > 0 )
	{
		$gs->writeAsDescriptor( $lfn );
	}
	else
	{
		debug "TK:   - Not needed, no dirty records\n" if $tkdebug;
	}

	map { $_->dirty(0) } $gs->getAllGhosts();

	delete $ghostStoreForDescriptorLFN{$lfn};

	return undef; 
}

sub getGhostDescriptorFileForLFN($)
{
	my $self = shift;
	my $filename = shift;

	# debug "GDF: $filename\n";

	die "Assert: $filename should be a path" if not main::assert_regularpath( $filename );

	my( $fn, $dir ) = fileparse( $filename );

 	my $dfn = File::Spec->catfile($dir, $DESCRIPTOR_FILENAME);

 	# debug "GDF [$dfn] for $filename\n";

	return $dfn;
}

sub getGhostStoreForDescriptorFileCoveringFN
{
	my $self = shift;
	my $lfn = shift;

	my $gsfn = $self->getGhostDescriptorFileForLFN( $lfn );

	if( exists $ghostStoreForDescriptorLFN{$gsfn} )
	{
		return( $ghostStoreForDescriptorLFN{$gsfn} );
	}
	else
	{
		# must revisit TODO - the point of this cache is that it shouldn't get too big
		# die "Overflow!" if ((keys %ghostStoreForDescriptorLFN) > 100);

		my $gs = GhostStore->new();

		if( -e $gsfn )
		{
			debug "Reading descriptor [$gsfn]\n" if $tkdebug;
			$gs->slurpDescriptor( $gsfn );
			debug "Incorporating stuff found in [$gsfn]\n" if $tkdebug;
			$self->incorporateGhostStore( $gs );

			# TODO
			# to properly handle identification of deleted files,
			# the ghosts should be added as children to whatever the
			# parent is
		}

		$ghostStoreForDescriptorLFN{$gsfn} = $gs;

		return $gs;
	}
}

# Takes everything we've learned from a ghost store and calls incorporate

sub incorporateGhostStore
{
	my $self = shift;
	my $gs = shift;

  # debug Dumper( $self );

	my @g = $gs->getAllGhosts();
	foreach my $g (@g)
	{
		$self->incorporateGhostData( $g );
	}

  # debug Dumper( $self );
}

# Takes everything we've learned from a ghost and incorporate it into our
# source of truth.  Ss a side effect, this may end up registering new ghosts
# as truthy. Either the ghost you provide is registered as the truthy ghost,
# or the existing one is updated.  Caller is always free to continue using
# whatever ghost they want but future lookups will always get a reference
# ghost with isTKVersion(1). If you want to be sure you are using that
# version, future use should be the TK version which is returns.

sub incorporateGhostData
{
	die "no longer checked";

	my $self = shift;
	my $g = shift;

	my $lfn = $g->lfn();
	my $ghostForLFN = $self->ghostForLFN();

	my $DID = $g->debugID();
	#debug "Incorporating ghost lfn:[$lfn] ptr:[$DID] (self=$self, glfn=$ghostForLFN)\n" if $icDebug;
	debug "Incorporating ghost lfn:[$lfn] ptr:[$DID]\n" if $icDebug;

	if( exists $ghostForLFN->{$g->lfn()} )
	{
		# merge case: My caller provided a ghost and I already have one in my registry

		my $base = $ghostForLFN->{$g->lfn()};
		if( $base == $g )
		{
			debug "  Incorporate: Asked to incorporate a ghost that is already truthy";
			die unless $base->isTKVersion() > 0;
			return;
		}

		# Now, presumably, I have a base that may need to be updated.

		$base->learnFromGhost( $g );

		# not super clear why this is here, maybe just affirmative?

		die "Assert: two ghosts authoritative to same LFN" if $g->isTKversion() > 0;

		$g->isTKversion(0);

		return $base; 
	}
	else
	{
		debug "  Incorporate -  Merger case - non-TK ghost we got is being declared the TK version\n" if $icDebug;

		$self->registerTruthyGhost( $g );
		$g->isTKversion(1);
		return $g;
	}
}


sub registerTruthyGhost
{
	my $self = shift;
	my $g = shift;

	my $lfn = $g->lfn();

	my $DID = $g->debugID();
	debug "Register Truthy Thing: [$lfn] -> $DID\n" if $tkdebug;

	my $ghostForLFN = $self->ghostForLFN();
	die "Collision [$lfn]" if exists $ghostForLFN->{$lfn};
	$ghostForLFN->{$lfn} = $g;
}

# Normal logic to get a ghost. Nearly all ghost construction should come
# through this routine.

sub obtainGhostForLFN
{
	my $self = shift;
	my $lfn = shift;

	my( $handler, $root, $path ) = main::parseFQLFN( $lfn );

	die "LFN is zero length" if ((length $lfn) < 1);
	die "LFN is not a clean string!" if ref $lfn;

	debug "TK:Obtain: obtain f:[$lfn] ($handler)($root)($path)- requested\n" if $tkdebug;

	my $ghostForLFN = $self->ghostForLFN();

	main::assert_cpath( $path );

	if( exists $ghostForLFN->{$lfn} )
	{
		debug "TK:Obtain: obtain f:[$lfn] - found in cache\n" if $tkdebug;
		return $ghostForLFN->{$lfn};		
	}

	debug( "TK:Obtain: Making new blank ghost for f:[$lfn]\n") if $tkdebug;
	my $g = Ghost->make_private( $lfn );
	$g->addDebugProvenance( "obtain/base($lfn)" ) if $provenanceDebug;
	# registers into our singleton cache
	
	$self->registerTruthyGhost( $g );
	
	my $DID = $g->debugID();
	debug "TK:Obtain: Made: $DID\n" if $tkdebug;

	$self->populateDataOnGhost($g);

	return $g;



	# Next look for in global cache (if present)
	# TODO when time comes, implement global cache

	# X X X X X X X X 

	# Next look in local descriptor
	#
	# TODO, this is sort of wrong -- the ghost
	# store is useless for certain types of LFNS really only things pretaining
	# to file system should hit descriptor refactor to move to FSE

	# if( $handler eq "fs" )
	# {
	# 	my $gs = $self->getGhostStoreForDescriptorFileCoveringFN($path);
	# 	my $g = $gs->findGhostForLFN($lfn);

	# 	my $DID = ref $g ? $g->debugID() : 'Not found';
	# 	debug "TK:Obtain: obtain f:[$lfn] pulled g:[$DID] from ghost descriptor\n" if $tkdebug;
		
	# 	if( defined $g )
	# 	{
	# 		# note: registration already occured by getGhostStore...FN()
	# 		return $g 
	# 	}
	# }

	# If this LFN is pointing to a container object, I think this is the
	# right place in the logic to force a load. This logic needs to be more
	# carefully considered.

	if( $handler eq "snap" )
	{
		die "Unclear on current status after refactor";
		debug "Obtain: container object load case" if $tkdebug; 
		
		my $g = Ghost->make_private( $lfn );
		# should this have been a virtual ghost?
		$g->addDebugProvenance( "obtain/snap($lfn)" );

		my $fse = FSEFactory->getFSEHandlerForGhost( $g );
		my $r = $fse->findGhostForLFN( $lfn );

		if( defined $r )
		{
			# note: registration already occured by getGhostStore...FN()
			return $r; 
		}
	}

	# Wow, we've totally stuck out here - make a new thing. When we get to
	# this point, how do we decide if this guy is going to be virtual or if
	# its going to be real?

	# debug( "TK:Obtain: Making new ghost for f:[$lfn]\n") if $tkdebug;
	# my $g = Ghost->make_private( $lfn );
	# $g->addDebugProvenance( "obtain/base($lfn)" );
	# # registers 
	# $self->incorporateGhostData( $g );
	# #$g->markDirty();
	# # MAJOR change - ghosts are no longer automatically dirty

	# $g->isTKversion(1);

	# if( $handler eq "fs" )
	# {
	# 	my $gs = $self->getGhostStoreForDescriptorFileCoveringFN( $path );
	# 	$gs->addGhost( $g );
	# }

	# my $DID = $g->debugID();
	# debug "TK:Obtain: Made: $DID\n" if $tkdebug;

	# return $g;
}



sub populateDataOnGhost
{
	my $self = shift;
	my $g = shift;

	my $lfn = $g->lfn();
	debug "Populating from global store: $lfn\n" if $tkdebug;

	my $gdb = GhostDatabase->getCore();
	$gdb->populateDataOnGhost($g);
}

sub saveGhostToStore
{
	my $self = shift;
	my $g = shift;

	my $lfn = $g->lfn();
	my $dirty = $g->dirty();
	my $id = $g->debugID();
	debug "Saving Ghost to disk: $lfn - $id - dirty=$dirty\n" if $tkdebug;

	if( $dirty )
	{
		my $gdb = GhostDatabase->getCore();
		$gdb->saveGhostToStore($g);
		$g->dirty(0);
	}

}




##########
#
# GhostIterator -- A helper for iterating over nested directories Note: Does
# not use File::Find! Everything is done through ghosts that request
# subdirectories so this is uber-clean.
#
# Recurse mode = everything goes back to TK
# NonRecurse Mode = only thigns in the parent are returned. 
#
####

package GhostIterator;

use File::Basename;
use base qw(Class::Accessor);
GhostIterator->mk_accessors( qw(queue recurse parentGhostStore) );

sub debug($)
{
	my $a = shift;
	main::debug( "GI: " . $a );
}

my $GI_DEBUG = 0; 

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();
	$self->recurse(0);
	return $self;
}

# Gets the next item in the iterator
#
# Behind the scenes, will call nextRaw and handle things in the queue
# that are unexpected

sub next
{
	my $self = shift;

	return $self->nextRecurse() if( $self->recurse() );
	return $self->nextNoRecurse() if( !$self->recurse() );
	return;

}

sub nextNoRecurse
{
	my $self = shift;
	
	my $q = $self->queue();
	my $c = shift @$q;

	if( not defined $c )
	{
		return undef; 
	}

	return $self->parentGhostStore()->findGhostForLFN($c) ; 
}


sub nextRecurse
{
	my $self = shift;

	my $n = $self->nextRaw();

	if( ref $n )
	{
		debug "GI: THUNK received --> $$n\n" if $GI_DEBUG;
		return $self->next();
	}

	# Check for the end-of-queue case
	if( not defined $n )
	{
		debug "GI iterator: Undef case - iterator over\n" if $GI_DEBUG;
		return undef;
	}

	my $tk = TruthKeeper::get();
	my $g = $tk->obtainGhostForLFN( $n );

	return $g;
}

# Internal helper function called when a directory needs to be expanded

sub scanDir
{
	my $self = shift;
	my $g = shift;
 	my $q = $self->queue();	

	# call getChildren
	# getChildren may have these buggers cached
	# caching should be weak
	# if not call up to TK and try to get from GCIP
	# if not FSM->getImmediateChildren;

	my $lfns = $g->getFSE()->getImmediateChildren( $g );

	$g->learnChildrenByLFN( time(), $lfns );

#	my @children = $g->getChildren();

 	unshift @$q, \$g;  # add the thunk that will tell us the directory is over
 	unshift @$q, @{$lfns}; # add the files themselves
}

sub nextRaw
{
	my $self = shift;

	my $q = $self->queue();
	my $c = shift @$q;

	if( not defined $c )
	{
		return undef; 
	}

	if( ref $c )
	{
		return $c; 
	}

	# Todo - clean up passing of ghosts back up to parent
	# issue here is that the parentGhostStore only has the top
	# level parents.
	# my $gs = $self->parentGhoststore();
	# my $g = $gs->findGhostForLFN( $c );

	# TODO: two obtains are called, first to check for being a directory
	# second, by next. This could be refined by making the queue
	# able to store both ghosts and LFNs.

	my $tk = TruthKeeper::get();
	my $g = $tk->obtainGhostForLFN( $c );

	debug "GI: Checking [$c]->[$g] for children\n" if $GI_DEBUG;

	# if the next thing is a directory, scan into the directory
	if( $g->canHaveChildren() )
	{
		debug "GI: Scan directory case\n" if $GI_DEBUG;
		$self->scanDir( $g );
	}

	return $c;
}

##########
#
# GhostStore - utility functions for dealing with arbitrary collections
# of ghosts
#
####

package GhostStore;

use File::Basename;
use POSIX;
use base qw(Class::Accessor);
GhostStore->mk_accessors( qw(lfnToGhost sizeToFNs isDecending ) );

sub debug($)
{
	my $a = shift;
	main::debug( "GS: " . $a );
}

sub CODEPATH($)
{	
	my $p = shift; 
	main::CODEPATH( "GS: $p" );
}

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();
	$self->lfnToGhost( +{} );
	$self->sizeToFNs( undef );
	$self->isDecending( 0 );

	return $self;
}

sub newDescending
{
	my $class = shift;
	my $self = $class->SUPER::new();
	$self->lfnToGhost( +{} );
	$self->sizeToFNs( undef );
	$self->isDecending( 1 );

	return $self;
}



## TODO

## ghost iterators now sort their contents why? well, turns out there is some
## non-deterministic behavior going on depending on how the values get scrabled
## into the cache and i need consistency. ideally though, we need a way of
## iterating through the ghost store in an order similiar to the one the user
## intendend.

sub getIterator
{
	my $self = shift;

	my $r = GhostIterator->new();
	$r->queue( [ sort keys %{$self->lfnToGhost()} ] );
	$r->recurse($self->isDecending() );
	$r->parentGhostStore( $self );
	return $r;
}

sub countDirty
{
	my $self = shift;

	my $i = 0;

	map {$i++ if defined $_->dirty() && $_->dirty() > 0 } $self->getAllGhosts();

	return $i;
}

sub findGhostForLFN
{
	my $self= shift;
	my $lfn = shift;

	my $lfnToGhost = $self->lfnToGhost();

	if(exists $lfnToGhost->{$lfn} )
	{
		debug "   Found inside ghoststore\n" if $gsDebug;
 		return $lfnToGhost->{$lfn};
 	}

 	return undef;
}

sub purifyAllGhostsToTK
{
	my $self = shift;
	my $tk = TruthKeeper::get();
	my $lfnToGhost = $self->lfnToGhost();

	foreach my $g (values %$lfnToGhost)
	{
		if( $g->isTKversion() == 0 )
		{
			debug "GhostStore: ***** PURIFY $g->lfn()\n" if $gsDebug;
			my $n = $tk->obtainGhostForLFN( $g->lfn() );
			$lfnToGhost->{$n->lfn()} = $n;
			CODEPATH( "GS purification");
		}
	}
}

sub printDebugShort
{
	my $self = shift;
		my $lfnToGhost = $self->lfnToGhost();
	print "GS", join ',', keys %$lfnToGhost;
}

sub printDebugMedium
{
	my $self = shift;
	my $lfnToGhost = $self->lfnToGhost();
	foreach my $g ($self->getAllGhosts() )
	{
		print "GS " . $g->debugID() . "  lfn:" . $g->lfn() . "\n";
		$g->printDebug();
	}
}


sub getAllGhosts
{
	my $self = shift;
	my $lfnToGhost = $self->lfnToGhost();
	return values %$lfnToGhost;
}

sub removeGhost($)
{
	my $self = shift;
	my $g = shift;

	my $lfn = $g->lfn();
	my $lfnToGhost = $self->lfnToGhost();

	my $DID = $g->debugID();
	debug "GhostStore: Remove ghost $DID (lfn=$lfn) from ghoststore\n" if $gsDebug;

	if( not exists $lfnToGhost->{$lfn} )
	{
		die "GhostStore: Boundary case - as to remove a ghost that doesn't exist";
	}

	delete $lfnToGhost->{$lfn};

	my $sizeToFNs = $self->sizeToFNs();

	# remove from size cache if it exists

	if( defined $sizeToFNs )
	{	
		if( defined $g->getSize() )
		{
			my $size = $g->getSize(); 
			my @r = grep { $lfn eq $_ } @{$sizeToFNs->{$size}};
			$sizeToFNs->{$size} = \@r;
		}
	}
}

sub addGhost($)
{
	my $self= shift;
	my $g = shift;

	my $lfn = $g->lfn();
	my $lfnToGhost = $self->lfnToGhost();

	warn "Something wrong lfn:$lfn" if $lfn eq ".";
	warn "Something wrong lfn:$lfn" if $lfn eq "..";

	my $DID = $g->debugID();
	debug "GhostStore: Adding ghost $DID (lfn=$lfn) to ghoststore\n" if $gsDebug;
	#debug "GhostStore: Adding ghost $DID (lfn=$lfn) (lfntoghosthash=$lfnToGhost gs_self=$self) ghoststore\n" if $gsDebug;

	if( exists $lfnToGhost->{$g->lfn()} )
	{
		die "GhostStore: Boundary case - adding ghost where one already existed";
	}

	$lfnToGhost->{$lfn} = $g; 

	$self->ghostStoreCacheTaint();

	return;
}

# Signal that membership in the store has changed, and that the caches 
# are probably not up to date. Conservative action is to revoke all caches.


sub ghostStoreCacheTaint
{
	my $self = shift;

	if( defined $self->sizeToFNs() )
	{
		CODEPATH( "Tainted ghoststore cache");
		$self->sizeToFNs( undef );
	}

}

# Pulls in the descriptor listed 

sub slurpDescriptor($)
{
	my $self = shift;
	my $fn = shift;

	debug "GhostStore: Slurping descriptor [$fn]\n" if $gsDebug;

	die "Assert: $fn should be a path" if not main::assert_regularpath( $fn );

	my( $parsedFn, $dir ) = fileparse( $fn );

	my $treebase = $dir; 

	$self->slurpSerializedStore( filename => $fn,
								 treeRoot => $treebase );

	# At this point, our ghosts are not linked to the TK, they are just versions of possible truth

	$main::run_descriptors_read++;
}

sub slurpSnapshot
{
	my $self = shift;
	my $fn = shift;
	my $root = shift;

	$self->slurpSerializedStore( filename => $fn,
								 immutable => 1, 
								 snapshotRoot => $root );
}


sub slurpSerializedStore
{
	my $self = shift;
	my %opt = @_;

	my $fn = $opt{filename} or die "Filename not provided to slurp!";

	my %seen;

	open( FILE, "<$fn") or die "Cannot open $fn to slurpSerializedStore";

	while( <FILE> )
	{
		chomp;
		debug "GhostStore: Slurping: [$_]\n" if $gsDebug;

		if( /^###/ )
		{
			next;
		}

		if( /^@@@\s*(\w+)\s*\=\s*(.*)/ )
		{
			my ($name, $value) = ($1,$2);
			debug "DESCRIPTOR: $name --> $value\n" if $gsDebug;

			if( $name eq 'version' )
			{
				debug "Comparing version $SERIALIZATION_VERSION_NUMBER to [$value]\n" if $gsDebug;

				if( $SERIALIZATION_VERSION_NUMBER != ($value+0) )
				{
					die "Version mismatch in $DESCRIPTOR_FILENAME: $SERIALIZATION_VERSION_NUMBER != [$value] -- the descriptor version is wrong. Delete the old descriptors to continue.";
				}
			}

			next;
		}

		my $g = Ghost->newFromSerialized( $_, %opt );
		$g->addDebugProvenance( "slurp($fn)" ) if $provenanceDebug;

		$g->isTKversion(0);
		$self->addGhost( $g );

		die "Ghost descriptor contains duplicates - some logic problem - see [$fn]!" if( $seen{$g->lfn()}++ > 0 );
	}

	close( FILE );
}





sub writeAsDescriptor($)
{
	my $self = shift;
	my $fn = shift;

	my $lfnToGhost = $self->lfnToGhost();

	open( FILE, ">$fn") or die "Cannot open file[$fn] to write descriptor: $!";

	my $date = strftime( "%c", localtime() );

	print FILE "### This is a checksum tracking file written by $0\n";
	print FILE "### File written on $date\n";
	print FILE "### It can be removed at any time with no harmful effects\n";
	print FILE "### \n";
	print FILE "### To remove this dotfile and others like it, try this command\n";
	print FILE "###    find . -name '$DESCRIPTOR_FILENAME' -print0  | xargs -0 rm -iv\n";
	print FILE "### \n";
	print FILE "@@@ version = $SERIALIZATION_VERSION_NUMBER\n";
	print FILE "### \n";

	foreach my $g ( values %$lfnToGhost )
	{
		$g->addDebugProvenance( "writeDesc($fn)");
		print FILE $g->serialize( pathMode => "basename" );
		print FILE "\n";

		if( $gsDebug )
		{
			my $lfn = $g->lfn();
			debug "    WAD: Write ($lfn):".  $g->serialize( pathMode => "basename");
		}
	}

	close( FILE );

	debug "    WAD: Wrote descriptor -> $fn\n" if $gsDebug;

	$main::run_descriptors_write++;
}


sub writeSnapshotToDisk
{
	my $self = shift;
	my $fn = shift;

	$self->writeSerializedToDisk( $fn, pathMode => 'localized' );
}

#  TODO combine codebase with descriptors

sub writeSerializedToDisk($)
{
	my $self = shift;
	my $fn = shift;
	my %options = @_;

	my $lfnToGhost = $self->lfnToGhost();

	open( FILE, ">$fn") or die "Cannot open $fn to write snapshot or descriptor";

	my $date = strftime( "%c", localtime() );

	print FILE "### This is a snapshot, written by the tool $0\n";
	print FILE "### File written on $date\n";
	print FILE "### It is a record of all of the files stored under a tree at a single point in time\n";
	print FILE "### The gfs tool can use this to reconstruct this specific file tree later\n";
	print FILE "### \n";
	print FILE "@@@ version = $SERIALIZATION_VERSION_NUMBER\n";
	print FILE "### \n";

	foreach my $g ( values %$lfnToGhost )
	{
		print FILE $g->serialize( %options );
		$g->addDebugProvenance( "writeSnap($fn)");
		print FILE "\n";
	}

	close( FILE );

	debug "Wrote snapshots -> $fn\n";
}

sub loadSizeCache
{
	my $self = shift;

	my $h = {};
	# my $tk = TruthKeeper::get();

	my $iterator = $self->getIterator();

	CODEPATH( "Gen size cache");

	debug "GS-Generating size cache\n";

	while( my $g = $iterator->next() )
	{
		#debug "GS-Generating size cache: $g\n";
		#$g->printDebug();

		next unless $g->isFile();
		my $size = $g->getSize();
		next if $size <= 0;

		if( $gsDebug )
		{
			my $lfn = $g->lfn();
			debug "GS - Size Cache lfn:[$lfn] -> $size\n" 
		}

		push @{$h->{$size}}, $g;
	}

	$self->sizeToFNs($h);
}

sub findFilesWithSize
{
	my $self = shift;
	my $s = shift;

	#debug "findFilesWithSize($s)";

	return undef if( $s <= 0 );

	if( not defined $self->sizeToFNs() )
	{
		$self->loadSizeCache();
	}

	my $lu = $self->sizeToFNs()->{$s};

	# debug "findFilesWithSize($s): $lu";

	return +() if not defined $lu;

	# Its theoretically possible the size cache is invalid. Quickly check our
	# answer. 

	my @c = @{$lu};
	my @r;
	foreach my $g (@c)
	{
		if( $g->size() != $s )
		{
			CODEPATH( "Rare case where ghoststore size cache returned stale data");
		}
		else
		{

			push @r, $g;
		}

	}




	return @r;
}

# Returns all ghosts other than the one passed that is a hash duplicate

sub findOtherDuplicates
{
	my $self = shift;
	my $g = shift;

	return grep { not $g->isSameFilename($_) } $self->findAllDuplicates($g);
}


# Returns every known ghost named in this collection that is a duplicate. A
# duplicate is defined as a file with the exact contents, even if things like
# mode or modification times differ.
#
# This is the most expensive duplicate finding operation since it is
# completionist -  all potential duplicates are verified. Note: duplicates may
# include  the ghost itself.

sub findAllDuplicates
{
	my $self = shift;
	my $target = shift;

	die "findAllDuplicates() passed invalid scalar" unless defined $target;

	my $size = $target->getSize();

	die "findAllDuplicates passed an invalide (size = undef) file" if not defined $size; 
	return () if $size < 1; 

	# First, check our size cache for a match
	my @otherFN = $self->findFilesWithSize( $size );

	return if @otherFN < 1;

    debug " -- Checking size duplicates size:[$size]\n" if $duplicateDebug;

	my @matches;

	foreach my $gc ( @otherFN )
	{
		#next if $gc->isSameFilename( $target );
		my $hit = 0;
		if( $target->isDuplicateOf( $gc ) )
		{
			$hit = 1;
			push @matches, $gc;
		}


		if( $duplicateDebug )
		# if( 1 )
		{
			my $cFN = $gc->lfn();
			my $tFN = $target->lfn();

			my $cD = $gc->quickDebugString();
			my $tD = $target->quickDebugString();
			


				debug "     -- Checking size duplicates size:[$size]\n";
				debug "     ---> cfn:[$cFN] $cD " .($hit?"HIT=Y":"HIT=N"). "\n";
				debug "  vs ---> tfn:[$tFN] $tD\n";
				
		}

	
	}

	return @matches;

	# return @matches;
}

# Returns a single ghost that is a duplicate, or undef if no such duplicate
# exists. In theory this can be implemented in a "leaner" way since once a
# single is found, no more hash duplicates need to be tested.

sub findSingleDuplicate
{
	my $self = shift;
	my $target = shift;

	my @r = $self->findOtherDuplicates( $target );

	return undef if @r < 1;
	return pop @r; 
}

sub findSingleDuplicateIncludingSelf
{
	my $self = shift;
	my $target = shift;

	my @r = $self->findAllDuplicates( $target );

	return undef if @r < 1;

	return pop @r; 
}

sub hasDuplicate
{
	my $self = shift;
	my $target = shift;

	# ideally if the size is not present, doesn't force any hashes
	# should check for that

	return $self->findSingleDuplicate($target);



}


##########
#
# Ghost - an imprint of a file that may or may not exist at a particular place
#
# The ghost is a carrier of information about a file, and intended to be
# lightweight More than one ghost can exist for a given file, and they can be
# different. To obtain an "authoritiative" ghost, the TruthKeeper is used to
# resolve them for instance a snapshot could have one version of a ghost, a
# descriptor a different and the one from the file system could yet again be
# different. Ghosts are intended to be so lightweight that they can be used as
# proxies for filename everywhere as of the "everthing-is-a-ghost" update,
# ghosts are used universally to handle files.
#
# Ghosts are never expected to change LFNs under any circumstances. The only
# acceptable time to assing an LFN is during deserialization or creation.
#
# Immutability is a key aspect of ghosts; an immutable ghost does not change
# any of its fields. Normal ghosts are expected to update themselves based on
# filesystem or data state. There are a set of atomic definable rules that say
# when new types of state refresh each ghost.#
#
# The ghost class does not itself hit the disk - everything is delegated to
# the FSE. This allows multiple different handlers to interpret the LFN the
# way they see fit.
#
# Terminology used in function names has some nuance
#
# -     size() - the internal size descriptor, never use this!!
# GET   getSize - gets an ACCEPTABLE size
# LEARN learnSize - tell me about new information pretaining to this ghost
#

package Ghost;

use File::Basename;
use base qw(Class::Accessor);

use Cwd qw(abs_path); # best way to get these


use Carp qw(cluck longmess shortmess);
use Data::Dumper;



# GHOST_NEW_FIELD: Place 4/5 where you add new fields to ghosts

Ghost->mk_accessors( qw(lfn lastFullHash size mode _fullHash statStruct
	uuid sequence effectiveDate attributes dirty isTKversion lastDirScan lastStat
	mtime lastEnumerated firstStat fileStatus
	lastChanged deepSize deepCount lastDeepScan
	children _immutable _debugID  ) );


my $GHOST_DEBUG_ID = 100000; 


sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();

	$self->_debugID( $GHOST_DEBUG_ID++ );

	$self->{_DEBUG_PROVENANCE} = [];

	return $self;
}

# simple utility for seeing where ghosts came from to track down tricky
# debugging scenarios

sub addDebugProvenance
{
	my $self = shift;
	my $str = shift;

	push @{$self->{_DEBUG_PROVENANCE}}, $str; 

} 


sub cloneForSignature
{
	my $self = shift;

	my $c = $self->new();

	$c->pullValuesFromGhostForSignature( $self );
	$c->setImmutable();
		
	if( $provenanceDebug )
	{
		my $sid = $self->debugID();
		my $cid = $c->debugID();
		$self->addDebugProvenance( "cloneto/SIG($cid)");
		$c->addDebugProvenance( "clonefrom/SIG($sid)");
	}

	return $c;
}

sub clone
{
	my $self = shift;

	my $c = $self->new();

	$c->pullValuesFromGhost( $self );
	
	if( $provenanceDebug )
	{
		my $sid = $self->debugID();
		my $cid = $c->debugID();
		$self->addDebugProvenance( "cloneto($cid)");
		$c->addDebugProvenance( "clonefrom($sid)");
	}

	return $c;
}

sub cloneWithLFN
{
	my $self = shift;
	my $lfn = shift;

	my $copy = $self->clone();

	# print "Clone $lfn\n";
	$copy->lfn( $lfn );

	return $copy;
}


sub setImmutable
{
	my $self = shift;
	$self->_immutable(1);
}



sub pullValuesFromGhostForSignature
{
	my $self = shift;
	my $target = shift;

	$self->lfn( 		     $target->lfn() );
	$self->size( 		     $target->size() );
	$self->mode( 		     $target->mode() );
	$self->fullHash( 	     $target->fullHash() );
	$self->mtime( 		     $target->mtime() );

	$self->dirty( 0 );
	$self->isTKversion( 0 );
}



sub pullValuesFromGhost
{
	my $self = shift;
	my $target = shift;

	# GHOST_NEW_FIELD: Place 5/5 where you add new fields to ghosts

	debug( "Pull values from ghost\n");

	$self->lfn( 		     $target->lfn() );
	$self->lastFullHash(     $target->lastFullHash() );
	$self->size( 		     $target->size() );
	$self->mode( 		     $target->mode() );
	$self->fullHash( 	     $target->fullHash() );
	$self->lastDirScan(      $target->lastDirScan() );
	$self->lastStat( 	     $target->lastStat() );
	$self->lastEnumerated(   $target->lastEnumerated() );
	$self->firstStat( 	     $target->firstStat() );
	$self->fileStatus( 	     $target->fileStatus() );
	$self->mtime( 		     $target->mtime() );

	$self->uuid( 		     $target->uuid() );
	$self->sequence( 	     $target->sequence() );
	$self->effectiveDate(    $target->effectiveDate() );
	$self->attributes( 	     $target->attributes() );

	$self->lastChanged( 	 $target->lastChanged() );
	$self->deepSize( 	     $target->deepSize() );
	$self->deepCount( 	     $target->deepCount() );
	$self->deepCount( 	     $target->lastDeepScan() );

	$self->statStruct( 	     $target->statStruct()->copy() );

	$self->dirty( 0 );
	$self->isTKversion( 0 );
}


sub debug($)
{
	my $a = shift;
	main::debug( "G: " . $a );
}

sub CODEPATH($)
{	
	my $p = shift; 
	main::CODEPATH( "Ghost: $p" );
}

sub debugID()
{
	my $self = shift;
	return $self->_debugID();
}

sub newFromSerialized($)
{
	my $class = shift;
	my $str = shift;
	my %options = @_;

	my $self = Ghost->new();

	my @a = split ':', $str;

	debug "Pre-GUS:" . join '|', @a if $granularSerialDebug;

	@a = map {main::gfs_unescape($_)} @a;

	debug "Post-GUS:" . join '|', map { defined $_ ? $_ : "undef" } @a if $granularSerialDebug;	

	my $serialLFN = shift @a;

	if( defined $options{'treeRoot'} )
	{
		my $root = $options{'treeRoot'};

		$serialLFN = main::rewriteLFNwithLeadingDirectory( $serialLFN, $root );
	}

	if( exists $options{snapshotRoot} )
	{
		my $newRoot = $options{snapshotRoot};

		$serialLFN = main::rewriteLFNreplaceRoot( $serialLFN, $newRoot );
	}


	if( defined $options{'immutable'} && $options{'immutable'} )
	{
		$self->_immutable(1);
	}

	# GHOST_NEW_FIELD: Place 1/5 where you add new fields to ghosts

	$self->lfn( $serialLFN );
	$self->effectiveDate( shift @a );
	$self->sequence( shift @a );
	$self->uuid( shift @a );
	$self->lastStat( shift @a );
	$self->lastFullHash( shift @a );
	$self->size( shift @a );
	$self->mode( shift @a );
	$self->mtime( shift @a );
	$self->fullHash( shift @a );
	$self->lastDirScan( shift @a );
	$self->lastEnumerated( shift @a );
	$self->firstStat( shift @a );
	$self->fileStatus( shift @a );
	$self->attributes( shift @a );
	$self->lastChanged( shift @a );
	$self->deepSize( shift @a );
	$self->deepCount( shift @a );
	$self->lastDeepScan( shift @a );



	my $statStructSerialized = shift @a; 
	if( defined $statStructSerialized )
	{
		my $statStruct = StatStruct->new();
		$statStruct->deserialize( $statStructSerialized );
		$self->statStruct( $statStruct );
	}
	else
	{
		$self->statStruct( undef );
	}


	$self->dirty( 0 );
	$self->isTKversion( 0 );

	if( $serializeDebug )
	{
		debug "Just deserialized: " . $self->makeDebugString();
	}	

	return $self;
}

sub isImmutable
{
	my $self = shift;

	return 0 if not defined  $self->_immutable();
	return 1 if  $self->_immutable() > 0 ;
	return 0; 
}

# getFSE - returns whatever FSE object is best for this thing

sub getFSE
{
	my $self = shift;
	my $lfn = $self->lfn();
	die unless defined $lfn;

	my $fse = FSEFactory->getFSEHandlerForGhost( $self );
	return $fse; 
}

sub getChildren()
{
	my $self = shift;

	my $tk = TruthKeeper::get();

	my $c = $self->getChildrenLFNs();

	my @r = map { $tk->obtainGhostForLFN( $_ ); } sort @$c;

	# think about changing this to a reference
	return @r;
}

# Caller wants the complete set of LFNs of our immediate children. (May force a scan.)

sub getChildrenLFNs
{
	my $self = shift;
	my $time = shift;

	# check our recency times. if we like them, return 
	# TODO

	if( $self->hasAcceptableEnumeration($time) )
	{
		debug( "gChild: getChildrenLFNS - hitting cache") if $gChildDebug;
		return $self->{CHILDREN_LFNS};
	}
	else
	{
		debug( "gChild: getChildrenLFNS - forcing source verify") if $gChildDebug;
		$self->getChildrenLFNsSourceVerify();
	}


	return $self->{CHILDREN_LFNS};
}


sub getChildrenLFNsSourceVerify
{
	my $self = shift;


	my $lfns = $self->getFSE()->getImmediateChildren( $self );

	# $self->{CHILDREN_LFNS} = $lfns;

	$self->learnChildrenByLFN( time(), $lfns );


}


# Looks for ghosts the worst possible way - a full recursive decent
# only used by debug code at the moment

sub findDuplicateGhostsUnderTreeFullScan
{
	my $self = shift;
	my $target = shift;

	my @c = $self->getChildren();

	debug $self->quickDebugString();
	my @results;

	foreach my $c (@c)
	{
		if( $c->isDuplicateOf($target ) )
		{
			my $q = $c->quickDebugString();
			debug "*** Duplicate found: $q\n";
			push @results, $c;
		}

		if( $c->canHaveChildren() )
		{
			my $r = $c->findDuplicateGhostsUnderTreeFullScan($target);
			push @results, @{$r};
		}


	}

	return \@results; 
}




# Returns true only if getChildren() is a complete list. We know this because
# we've summed up the signatures of our kids and they match. Once this step is
# done once per ghost, a flag is set and it doesn't need to be done again

# Tells us if the object's children list is up to date

sub hasAcceptableEnumeration
{
	my $self = shift;
	my $timeguard = shift;

	if( !defined $self->lastEnumerated() )
	{
		debug( "gChild: hasAcceptableEnumeration - no previous enum, forcing scan") if $gChildDebug;
		return 0;
	}

	if( !defined $self->{CHILDREN_LFNS} )
	{
		debug( "gChild: hasAcceptableEnumeration - not loaded, forcing scan") if $gChildDebug;
		return 0;
	}

	if( defined $timeguard && $self->lastEnumerated() < $timeguard )
	{
		CODEPATH( "invalidating lastEnumerated due to timeguard" );
		return 0;
	}
	
	if( defined $main::GUARD_TIME_SECONDS_ENUMERATION )
	{
		my $age = $main::SCRIPT_START - $self->lastEnumerated();

		# print "$age > $main::GUARD_TIME_SECONDS_ENUMERATION\n";

		if( $age > $main::GUARD_TIME_SECONDS_ENUMERATION )
		{
			CODEPATH( "lastEnumerated too old, recheck forced" );
			debug ( join '', "Forcing enumeration recalculation (", main::expressRelativeTime( $age ), ")\n");
			return 0; 
		}
	}


	# and expensive double check!!! TODO revisit this. 

	my $Vhash = $self->calculateUnforcedSignatureHashOverChildren();

	#print "Final check on hash...";

	my $fh = $self->fullHash();

	# print "Comparing caclulated [$Vhash] to stored [$fh]\n";

	die "internal consistency check issue" if $Vhash ne $fh;


	return 1;
}





# Caller is giving us a complete list of our children from primary source
# Mark the deleted ones and perform other flags

sub learnChildrenByLFN()
{
	my $self = shift;
	my $time = shift;
	my $lfns = shift; 


	my @lfns = @$lfns;

	my $tk = TruthKeeper::get();

	# Ideally, we call getChildren and do some sort of "merge"

	my @existingGhosts =  ref $self->{CHILDREN_LFNS} ?  @{$self->{CHILDREN_LFNS}} : (); # 0 ? @{$self->children()} : ();

	debug "Existing ghosts @existingGhosts\n" if $gChildDebug;

	my %seenLFN;
	my @newKids;

	my $hadExistingGhosts = @existingGhosts > 0 ? 1 :0;  
	my $hasContentsChanged = 0; 

	foreach my $e (@existingGhosts)
	{
		 $seenLFN{ $e->lfn() } = 0;
	}

	foreach my $lfn ( @lfns )
	{
		debug "G: Learning child: lfn:[$lfn]\n" if $gChildDebug;
		if( exists $seenLFN{$lfn} )
		{
			debug "G:   Child already registered\n" if $gChildDebug;
		}
		else
		{
			debug "G:   Child already registered\n" if $gChildDebug;
			$hasContentsChanged = 1;
		}

		$seenLFN{$lfn}++;

		my $g = $tk->obtainGhostForLFN( $lfn );
	
		# inform ghost that it has been seen in a directory scan
		# this also undeletes it
		$g->learnDirscan($time);
		push @newKids, $g;
	}

	foreach my $lfn ( keys %seenLFN )
	{
		if( $seenLFN{$lfn} < 1 )
		{
			debug "G:   Child has disapeared\n" if $gChildDebug;
			my $g = $self->tk()->obtainGhostForLFN( $lfn );
			$g->learnDeleted($time);
			$hasContentsChanged = 1; 
		}
	}

	$self->{CHILDREN_LFNS} = $lfns;

	$self->learnEnumerated($time);

	if( $hasContentsChanged and $hadExistingGhosts )
	{
		$self->hasContentsChanged( $time );
	}

}

# Popualtes the hash of a directory object as well as the deep fields. time is
# the timepoint we should assume this operation was performed. Used mainly so
# that  all writen data appears in lock step. Good policy is to call it with
# the current time if in doubt.

sub calculateDeepFields
{
	my $self = shift;
	my $time = shift;

	if( not $self->canHaveChildren() )
	{
		$self->lastDeepScan($time);
		return;
	}

	my $earliestDateHash = time();
	my $earliestDeepScan = time();
	my $buffer = ""; 

	my $tk = TruthKeeper::get();

	my $totSize = 0;
	my $totCount = 0;

	# Interesting case where we aren't actually calling isValidEnum?
	# yes, actually, we are calling it through getChildrenLFNs
	# TODO

	foreach my $lfn ( sort @{$self->getChildrenLFNs($time)} )
	{
		next if main::fileIsUsuallyIgnored( $lfn );
		my $g = $tk->obtainGhostForLFN($lfn);
		$g->calculateDeepFields( $time );


		$g->forceCharacterization();


		$earliestDateHash = $g->lastFullHash() if ( $g->lastFullHash() < $earliestDateHash );
		$earliestDeepScan = $g->lastDeepScan() if ( $g->lastDeepScan() < $earliestDeepScan );
		$totSize += $g->getDeepSize(); 
		$totCount += $g->getDeepCount(); 

		my $gSig = $g->cloneForSignature();
		my $gBuf = $gSig->serialize(pathMode=>'strict-basename');
		$buffer .= $gBuf . "\n";

		print "CSHOC: $gBuf\n";

		$g->flush();

	}


	my $sha = Digest::SHA->new(1);
	$sha->add( $buffer );
	my $hexdigest = $sha->hexdigest();


	if( 1 )
	{
		my $ed = $self->quickDebugString();
		print "calculateSignatureHashOverChildren($ed)($time) => $hexdigest, $earliestDateHash\n";
	}

	# as an optimization, we could have a guard time on deep scans, 
	# and then only recalculate where needed. Code should work either way.

	$self->learnFullHash( $earliestDateHash, $hexdigest );
	$self->learnDeepScan( $earliestDeepScan, $totSize, $totCount );
}

# Based on the currently registered directories, calculates the current checksum.
# Unlike the deepFields call, this one does not force the answer from subdirectories

sub calculateUnforcedSignatureHashOverChildren
{
	my $self = shift;

	my $buffer = $self->generateTreeSignatureBuffer();
	return undef if not defined $buffer;

	my $sha = Digest::SHA->new(1);
	$sha->add( $buffer );
	my $hexdigest = $sha->hexdigest();

	if( 0 )
	{
		my $ed = $self->quickDebugString();
		print "calculateSignatureHashOverChildren($ed) => $hexdigest\n";
	}

	return $hexdigest;
}

sub generateTreeSignatureBuffer
{
	my $self = shift;
	my $buffer = ""; 
	
	my $lfn = $self->lfn();

	# print "createTreeSignatureBuffer: Calculating unforced signature: $lfn\n";

	my $tk = TruthKeeper::get();
	my @c = map { $tk->obtainGhostForLFN( $_ ); } sort @{$self->{CHILDREN_LFNS}};

	foreach my $g ( @c )
	{
		my $lfn = $g->lfn();
	next if main::fileIsUsuallyIgnored( $lfn );

		#print "Checking $lfn\n";

		return undef if( !$g->isFullyCharacterized() );

	
		my $gSig = $g->cloneForSignature();
		my $gBuf = $gSig->serialize(pathMode=>'strict-basename');
		$buffer .= $gBuf . "\n";

		#print "SigBufferGen: $gBuf\n";
	}

	return $buffer;

}



# Returns the current deep size of the object. The time parameter is passed to
# "hasAcceptableDeepScan". If defined, it acts as the time guard for the information
# returned;

sub getDeepSize
{
	my $self = shift;
	my $time = shift;

	if( $self->canHaveChildren() )
	{
		if( ! $self->hasAcceptableDeepScan( $time ) )
		{
			my $t = time();
			$self->calculateDeepFields( $t );
		}
		return $self->deepSize();
	}

	return $self->getSize();
}

sub getDeepCount
{
	my $self = shift;
	my $time = shift;

	if( $self->canHaveChildren() )
	{
		if( ! $self->hasAcceptableDeepScan( $time ) )
		{
			my $t = time();
			$self->calculateDeepFields( $t );
		}
		return $self->deepCount();
	}

	return 1;
}

sub learnDeepScan
{
	my $self = shift;
	my $time = shift;
	my $deepSize = shift;
	my $deepCount = shift;

	die if $self->isImmutable();



	my $q = $self->quickDebugString();

	my $hasSigChanged = 0;

	if( $learnDebug )
	{
		my $__time = defined $time ? $time : "<undef>";
		my $__deepSize = defined $deepSize ? $deepSize : "<undef>";
		my $__deepCount = defined $deepCount ? $deepCount : "<undef>";
		debug "LEARN DEEP time:[$__time] size:[$__deepSize] cound:[$__deepCount] for $q\n";
		$self->printDebug();
	}

	die unless defined $time;

	die "incoming information newer than current time ($time)" if $time > time();

	$self->verifyGhostIsMutable();

	if( defined $self->lastDeepScan() and $time < $self->lastDeepScan() )
	{
		# reject older data
		return;
	}

	# At this point, we're convinced the new data is valid, but the qeuestion
	# is if its new enough to incorporate.

	my $isAnythingChanged = 0; 

	if( (defined $self->deepSize()) and ($deepSize ne $self->deepSize() ))
	{
		CODEPATH( "Newer deepSize information accepted"); 

		$hasSigChanged = 1;
		$isAnythingChanged = 1; 
	}

		if( (defined $self->deepCount()) and ($deepCount ne $self->deepCount() ))
	{
		CODEPATH( "Newer deepCount information accepted"); 

		$hasSigChanged = 1;
		$isAnythingChanged = 1; 
	}

	if( (defined $deepSize) and !(defined $self->deepSize()))
	{
		CODEPATH( "First deepSize information accepted"); 
		$isAnythingChanged = 1; 
	}		

		if( (defined $deepCount) and !(defined $self->deepCount()))
	{
		CODEPATH( "First deepCount information accepted"); 
		$isAnythingChanged = 1; 
	}	

	if( !defined $self->lastDeepScan() )
	{
		$isAnythingChanged = 1; 
	}
	elsif( $self->lastDeepScan() < $time )
	{
		CODEPATH( "Updated date of lastDeepScan"); 
		$isAnythingChanged = 1; 
	}


	if( 1 )
	{	
		my $id = $self->debugID();
		my $deepSizeX = defined $deepSize ? $deepSize : "_UNDEF__";
		my $deepCountX = defined $deepCount ? $deepCount : "_UNDEF__";
		debug "Learn DEEP Decision: $id lastDeepScan:[$time] deepSize:[$deepSizeX] deepCount:[$deepCountX]" if $learnDebug;
	}


	$self->lastDeepScan( $time );
	$self->deepSize( $deepSize );
	$self->deepCount( $deepCount );

	debug "Accepted deep size / deep count\n" if $learnDebug;;

	debug "Learn DEEP: isAnythingChanged? $isAnythingChanged" if $learnDebug; 	

	$self->markDirty( $time, "deep") if $isAnythingChanged;

	if( $hasSigChanged )
	{
		$self->learnContentsChanged($time);
	}



}

# Returns true if the deep scan data on the object appears valid. If the user
# provides a timeguard, this is used to set a bound on the age of the data.

sub hasAcceptableDeepScan
{
	my $self = shift;
	my $timeguard = shift;

	if( $staleInfoDebug )
	{
		my $q = $self->quickDebugString();
		my $x = defined $timeguard ? $timeguard : "undef";
		debug "hasAcceptableDeepScan:($x) $q\n" 
	}

	#$self->printDebug();


	return 1 if $self->isImmutable();

	if( not defined $self->lastDeepScan() )
	{
		debug "    hasAcceptableDeepScan: NO - no previous deep scan\n" if $staleInfoDebug;
		return 0;
	}

	if( defined $timeguard && $self->lastDeepScan() < $timeguard )
	{
		CODEPATH( "invalidating lastDeepScan due to timeguard" );
		debug "    hasAcceptableDeepScan: NO lastDeepScan:($timeguard) - timeguard case\n" if $staleInfoDebug;;
		return 0;
	}

	if( defined $main::GUARD_TIME_SECONDS_DEEPSCAN )
	{
		my $age = $main::SCRIPT_START - $self->lastStat();

		if( $age > $main::GUARD_TIME_SECONDS_DEEPSCAN )
		{

			CODEPATH( "deep scan too old, recheck forced" );
			debug (join '', "    hasAcceptableDeepScan: NO  Forcing recalculation (", main::expressRelativeTime( $age ), ")\n" ) if $staleInfoDebug;
			return 0; 
		}
	}

	debug "    hasAcceptableDeepScan: YES\n" if $staleInfoDebug;

	return 1;

}






# Called when we've received definitive information (either from registerChild
# or from a full scan) that we have a full enumeration of our contents.  If
# hashes are available of our children, this will create the compound hash and
# update the lastHashDate.

sub learnEnumerated
{
	my $self = shift; 
	my $time = shift; 

	$self->lastEnumerated( $time );
	$self->markDirty($time, "enum");
	debug "Learned: Fully enumed" if $learnDebug;
}

# indicates that a LFN is thought to be a child of this ghost.  We only
# consider ourselves to be fully enumerated if either we are explicity told
# that (learn()) or if  the hash signatures of our children sum up to the hash
# we have on file.

# Note: clears the fullyEnumerated flag, and also revokes our current fullHash
# and fullHashdate.

sub registerChildLFN
{
	my $self = shift; 
	die "ni";
}	

# canHaveChildren() - True if we can descend with a call to "getChildren"

sub canHaveChildren
{
	my $self = shift;

	# debug "Fetching type\n";

	my $type = $self->getType();

	# debug "Type is: $type\n";

	# base case: no knowledge or hash

	if( $type eq 'd' )
	{
		return 1;
	}

	return 0;
}


sub isSingleFile
{
	my $self = shift;
	my $type = $self->getType();
	return 1 if $type eq 'f';
	return 0; 
}

sub printDebug
{
	my $self = shift;

	debug $self->makeDebugString();

}

sub quickDebugString
{
	my $self = shift;

	my $debugID = $self->_debugID();
	my $size 			= defined( $self->size() ) 		? $self->size() : "_";
	my $lfn 			= defined( $self->lfn() ) 		? $self->lfn() : "_";
# my $immutable 		= defined( $self->_immutable() ) 		? $self->_immutable() : "_";
	my $fullHash 		= defined( $self->fullHash() ) 		? $self->fullHash() : "_";

	$fullHash =~ /(\w{5,5})$/;
	my $fh = $1 || "_";
	my $ix = defined $self->_immutable() ? ($self->_immutable() >0 ? "I+" : "I-" ) : 'I_'; 

	return "$debugID/$size/$fh/$ix/$lfn";
}

sub makeDebugString
{
	my $self = shift;

	# GHOST_NEW_FIELD: Place 2/4 where you add new fields to ghosts

	# Warning: Don't fire of any  "getXXX" here
	no warnings;

	my $lfn 			= defined( $self->lfn() ) 		? $self->lfn() : "undef";
	my $lastFullHash 	= defined( $self->lastFullHash() ) 		? $self->lastFullHash() : "undef";
	my $size 			= defined( $self->size() ) 		? $self->size() : "undef";
	my $mode 			= defined( $self->mode() ) 		? $self->mode() : "undef";
	my $fullHash 		= defined( $self->fullHash() ) 		? $self->fullHash() : "undef";
	my $lastDirScan 	= defined( $self->lastDirScan() ) 		? $self->lastDirScan() || '<none>' : "undef";
	my $lastStat 		= defined( $self->lastStat() ) 		? $self->lastStat() : "undef";
	my $mtime 			= defined( $self->mtime() ) 		? $self->mtime() : "undef";
	my $lastEnumerated 	= defined( $self->lastEnumerated() ) 		? $self->lastEnumerated() : "undef";
	my $firstStat 		= defined( $self->firstStat() ) 		? $self->firstStat() : "undef";
	my $fileStatus 		= defined( $self->fileStatus() ) 		? $self->fileStatus() : "undef";
	my $immutable 		= defined( $self->_immutable() ) 		? $self->_immutable() : "undef";
	my $statStruct 		= defined( $self->statStruct() ) 		? $self->statStruct()->serialize() : "undef";
	my $uuid 		= defined( $self->uuid() ) 		? $self->uuid() : "undef";
	my $sequence 		= defined( $self->sequence() ) 		? $self->sequence() : "undef";
	my $effectiveDate 		= defined( $self->effectiveDate() ) 		? $self->effectiveDate() : "undef";
	my $attributes 		= defined( $self->attributes() ) 		? $self->attributes() : "undef";
	my $lastChanged 		= defined( $self->lastChanged() ) 		? $self->lastChanged() : "undef";
	my $deepSize 		= defined( $self->deepSize() ) 		? $self->deepSize() : "undef";
	my $deepCount 		= defined( $self->deepCount() ) 		? $self->deepCount() : "undef";
	my $lastDeepScan 		= defined( $self->lastDeepScan() ) 		? $self->lastDeepScan() : "undef";



	# not technically a field but we should include this

	my $type = defined $self->mode() ? $self->extractTypeFromMode( $self->mode() ) : "???";
	# my $type = $self->getType();

	my $debugID = $self->_debugID();

	my $p = join '->', @{$self->{_DEBUG_PROVENANCE}};

	return "ghostDump($debugID): lfn:[$lfn] uuid:[$uuid] seq:[$sequence] eDT:[$effectiveDate] type:[$type] mode:[$mode] l_FH:[$lastFullHash] ".
	"full:[$fullHash] ldirscan:[$lastDirScan] l_stat:[$lastStat] size:[$size]".
	" mtime:[$mtime] immutable[$immutable] statStruct:[$statStruct] attr:[$attributes] provenance:[$p]".
	"lastCx:[$lastChanged] deepSz:[$deepSize] deepCt[$deepCount] lastDeepScan:[$lastDeepScan]";
}

sub isSameFilename
{
	my $self = shift;
	my $other = shift;

	my $fn1 = $self->getPath();
	my $fn2 = $other->getPath();

	# After some testing, it appears that abs_path (also see realpath(3)) 
	# is the very best way to test for complete filename equivilence
	# The testing read-out is below and turned off for now

	if( 0 )
	{
		debug "Checking if two files are the same filename:\n";
		debug "   me: [$fn1]\n";
		debug "   tg: [$fn2]\n";
	  
	  	my $cwd1 = abs_path( $fn1 );
	  	my $cwd2 = abs_path( $fn2 );

	 	debug "Using Cwd Abs_path:\n"; 
	  	debug "   me: [$cwd1]\n";
		debug "   tg: [$cwd2]\n";

	  	my $abs1 = File::Spec->rel2abs( $fn1 );
	  	my $abs2 = File::Spec->rel2abs( $fn2 );

	 	debug "Using rel2abs:\n"; 
	  	debug "   me: [$abs1]\n";
		debug "   tg: [$abs2]\n";
	}

	die "Incomplete info self-size" if not defined $self->lfn();
	die "Incomplete info other-size" if not defined $other->lfn();

	# TODO: revisit if perl libraries give a better way to do this

	 my $a = $self->absoluteLFN();
	my $b  = $other->absoluteLFN();
	my $r = $a eq $b;


	debug "isSameFilename a:[$a] b:[$b] result:[$r]";

	return 1 if $r;
	return 0;
}


sub absoluteLFN
{
	my $self = shift;
	return $self->getFSE()->getAbsoluteLFNForGhost($self);
}

sub isDuplicateOf
{
	my $self = shift;
	my $other = shift;

	# die "Incomplete info self-size" if not defined $self->size();
	# die "Incomplete info other-size" if not defined $other->size();

	if( $duplicateDebug )
	{

		my $q1 = $self->quickDebugString();
		my $q2 = $other->quickDebugString();
		debug "isDuplicateOf -  self: $q1\n";
		debug "isDuplicateOf - other: $q2\n";
	}

	my $sSize = $self->getSize(); 
	my $oSize = $other->getSize();

	if( $duplicateDebug )
	{
		debug "isDuplicateOf -  self-getSize=$sSize\n";
		debug "isDuplicateOf - other-getSize=$oSize\n";
	}

	if( $sSize != $oSize )
	{
		debug "isDuplicateOf - Answer=NO (size)\n";
		return 0;
	}



#   die "Incomplete info self full hash" if not defined $self->fullHash();
#	die "Incomplete info other full hash " if not defined $other->fullHash();

		my $mH = $self->getFullHash();
		my $oH = $other->getFullHash();

	if( $duplicateDebug )
	{

		my $mI = $self->debugID();
		my $oI = $other->debugID();
		debug "isDuplicateOf - forcing hash $mH - $oH ($mI and $oI)\n";
	}



	return 1 if( $mH eq $oH );

	return 0; 
}

sub serialize()
{
	my $self = shift;
	my %options = @_;

	my $lfn = $self->lfn();

	#debug "Serialize $self\n";

	if( exists $options{'pathMode'} and $options{'pathMode'} eq 'basename' )
	{
		$lfn = main::rewriteLFNPathToBasename( $lfn )
	}

	if( exists $options{'pathMode'} and $options{'pathMode'} eq 'strict-basename' )
	{
		my( $handler, $root, $path ) = main::parseFQLFN( $lfn );
		$lfn = basename( $path );
	}

	my $statStructSerialized = undef; 
	if( defined $self->statStruct() )
	{
		$statStructSerialized = $self->statStruct()->serialize();
	}

	# GHOST_NEW_FIELD: Place 3/4 where you add new fields to ghosts

	my @s = ( $lfn, 
			  $self->effectiveDate(),
			  $self->sequence(),
			  $self->uuid(),
			  $self->lastStat(),
			  $self->lastFullHash(),
			  $self->size(),
			  $self->mode(),
			  $self->mtime(),
			  $self->fullHash(),
			  $self->lastDirScan(),
			  $self->lastEnumerated(),
			  $self->firstStat(),
			  $self->fileStatus(),
			  $self->attributes(),
			  $self->lastChanged(),
			  $self->deepSize(),
			  $self->deepCount(),
			  $self->lastDeepScan(),
			  $statStructSerialized
			  );

	debug "PRE-GFSE:" . join '|', map { defined $_ ? $_ : "undef" } @s if $granularSerialDebug;	

	@s = map {main::gfs_escape($_)} @s;

	debug "Post-GFSE:" . join '|', map { defined $_ ? $_ : "undef" } @s if $granularSerialDebug;	


	my $s = join ':', @s;

	return $s;
}

# as of refactor, only TK is really allowed to called this

sub getHandler
{
	my $self = shift;
	my ($handler, $root, $path ) = main::parseFQLFN( $self->lfn() );
	return $handler;
}

sub getRoot
{
	my $self = shift;
	my ($handler, $root, $path ) = main::parseFQLFN( $self->lfn() );
	return $root;
}

sub getPath
{
	my $self = shift;
	my ($handler, $root, $path ) = main::parseFQLFN( $self->lfn() );
	return $path;
}

sub getLFNcompontents
{
	my $self = shift;
	my ($handler, $root, $path ) = main::parseFQLFN( $self->lfn() );
	return ($handler, $root, $path);
}

sub make_private($)
{
	my $class = shift;
	my $lfn = shift;

	my $self = $class->new();

	# debug "Ghost: Making ghost for lfn=[$lfn]\n";

	$self->lfn( $lfn );

	return $self;
}

sub make
{
	die "Assert - old code, warning!!";
}

# Forces the key fields to be loaded if they aren't already known
# Does not recheck them against the disk unless the standard

# TODO: implement size and fasthash

sub forceCharacterization
{
	my $self = shift;

	$self->getFullHash();
	$self->getSize();
	# $self->getFastHash();	
}

sub isFullyCharacterized
{
	my $self = shift;

	return 0 if not defined $self->lastFullHash();
	return 0 if not defined $self->fullHash();
	return 0 if not defined $self->size();
	return 0 if not defined $self->lastStat();

	return 1; 

}


sub hasAcceptableFullhash
{
	my $self = shift;
	my $timeguard = shift;

	my $timeguardx = defined $timeguard ? $timeguard : "_undef_";

	if($staleInfoDebug)
	{
	my $q= $self->quickDebugString();
	debug "hasAcceptableFullhash:($timeguardx) $q\n" 
	}

	# debug "Checking if I like my hash\n";

	if( $self->isImmutable() )
	{
			debug "hasAcceptableFullhash:($timeguardx) - Immutable\n" if $staleInfoDebug;;

		#debug "I'm immutable - i like my hash";
		return 1;
 	}

	if( not defined $self->fullHash() or $self->fullHash() eq "" )
	{
			debug "hasAcceptableFullhash:($timeguardx) not defined\n" if $staleInfoDebug;;

		#debug "has not defined, reject";
		return 0;
	}

	if( defined $timeguard && $self->lastFullHash() < $timeguard )
	{
			debug "hasAcceptableFullhash:($timeguardx) explicit timeguard\n" if $staleInfoDebug;

		CODEPATH( "invalidating fullHash due to timeguard" );
		return 0;
	}
	
	if( defined $main::GUARD_TIME_SECONDS_FULLHASH )
	{
		my $age = $main::SCRIPT_START - $self->lastFullHash();

		if( $age > $main::GUARD_TIME_SECONDS_FULLHASH )
		{
			CODEPATH( "Hash too old, recheck forced" );
				debug "hasAcceptableFullhash:($timeguardx) implicit timeguard\n" if $staleInfoDebug;

			debug ( join '', "Forcing hash recalculation (", main::expressRelativeTime( $age ), ")\n") if $staleInfoDebug;
			return 0; 
		}
	}

	debug "hasAcceptableFullhash:() HASH OK\n" if $staleInfoDebug;

	# debug "Yes, hash is OK.";

	return 1;
}

# returns an acceptable fullHash for the ghost
# Normally, the latest cached data is trusted, but
# this function can be set to take a out of data criteria in future TODO

sub getFullHash
{
	my $self = shift;

	if( $self->hasAcceptableFullhash() )
	{
		return $self->fullHash();
	}
	else
	{
		# The key strategy here is to stat the file twice before and after.
		# This ensures that the file isn't changing underneath us

		my $t = time();

		$self->getStatSourceVerify( $t );
		return undef if not $self->exists();
		$self->getFullHashSourceVerify( $t );
		$self->getStatSourceVerify( $t );

		return $self->fullHash(); 
	}
}


sub hasAcceptableStat
{
	my $self = shift;
	my $timeguard = shift;

	if( $staleInfoDebug )
	{
		my $q = $self->quickDebugString();
		my $x = defined $timeguard ? $timeguard : "undef";
		debug "hasAcceptableStat:($x) $q\n" 
	}

	return 1 if $self->isImmutable();

	return 0 if( not defined $self->lastStat() );

	if( defined $timeguard && $self->lastStat() < $timeguard )
	{
		CODEPATH( "invalidating stat due to timeguard" );
		debug "    hasAcceptableStat:($timeguard) - timeguard case\n" if $staleInfoDebug;;
		return 0;
	}

	if( defined $main::GUARD_TIME_SECONDS_STAT )
	{
		my $age = $main::SCRIPT_START - $self->lastStat();

		if( $age > $main::GUARD_TIME_SECONDS_STAT )
		{

			CODEPATH( "Hash too old, recheck forced" );
			debug (join '', "    hasAcceptableStat: Forcing recalculation (", main::expressRelativeTime( $age ), ")\n" ) if $staleInfoDebug;
			return 0; 
		}
	}

	return 1;
}

# TODO factor out hasAcceptable patttern into "bringStatToDateIfNeeded()"


sub getMode
{
	my $self = shift;

	if( $self->hasAcceptableStat() )
	{
		return $self->mode();
	}
	else
	{
		$self->getStatSourceVerify( time() );
		return $self->mode();
	}	
}


sub getSize
{
	my $self = shift;

	if( $self->hasAcceptableStat() )
	{
		return $self->size();
	}
	else
	{
		$self->getStatSourceVerify( time() );
		return $self->size();
	}	
}

sub getMTime
{
	my $self = shift;

	if( $self->hasAcceptableStat() )
	{
		return $self->mtime();
	}
	else
	{
		$self->getStatSourceVerify( time() );
		return $self->mtime();
	}	
}

sub verifyGhostIsMutable
{
	my $self = shift;
	die "Mutable operation attempted on immutable ghost!" if $self->isImmutable();
}


###########
# Storage semantics
#
# Represents the idea that you want the thing pointed to by this ghost to assume
# the identical contents of the ghost being pointed to. This is one of those
# wonderful things that we just pass over to the FSE.
#



sub store
{
	my $self = shift;
	my $thing = shift;

	return $self->getFSE()->store( $thing, $self );
}

# Makes a smallfile file - needed because GFS does not copy files that are
# zero bytes. In the future, can also be used to speed up files with very
# small amounts of data where the ghost itself is sufficent to recover the contents.

sub touchSmallfile
{
	my $self = shift;

	return $self->getFSE()->touchSmallfile( $self );
}

######


sub moveGhost
{
	my $self = shift;
	my $thing = shift;

	return $self->getFSE()->moveGhost( $self, $thing );
}




############


sub forDuplicatesMap()
{
	my $self = shift;
	my $fitFunction = shift; 


	# This is our lone check for enumeration, not really great

	my $c = $self->getChildrenLFNs();

	die "Warning - tree does not appear to have been enumerated recently." if not defined $self->fullHash();

	return $self->getFSE()->forDuplicatesMap( $self, $fitFunction);
}




sub findDuplicateUnderTree()
{
	my $self = shift;
	my $thing = shift;
	my $just_one = shift; 


	# This is our lone check for enumeration, not really great

	my $c = $self->getChildrenLFNs();

	die "Warning - tree does not appear to have been enumerated recently." if not defined $self->fullHash();

	return $self->getFSE()->findDuplicateUnderTree( $self, $thing, $just_one);
}



###########
# Getting a hardfile
#
# Gets you a path with that object that is free and clear for readonly
# purposes. Fills in the gap that possibly a file is on a remote server.
#

sub getReadonlyHardFile
{
	my $self = shift;

	return $self->getFSE()->getReadonlyHardFile($self);
}





sub generateAlternativeLocation
{
	my $self = shift;
	my $strategy = shift; 

	return $self->getFSE()->generateAlternativeLocation($self, $strategy);
}


###########
# Tests for existence
#
# The exists() semantic tells you definitively if the file is present or not within
# the window of knowledge of the time range given. Default does not actually hit the disk.
#
# 

sub exists()
{
	my $self = shift;
	my $time = shift;


	if( $self->isImmutable() )
	{
		warn "Untested case of exists on something immutable()";
		return 1; 
	}

	return $self->getStatPresence($time);
}


sub getStatPresence
{	
	my $self = shift;
	my $time = shift;  # ok to be undefined

	if( not $self->hasAcceptableStat($time) )
	{
		$self->getStatSourceVerify( time() );
	}

	if( main::statModeParse_isError( $self->mode() ) )
	{
		return 0; 
	}

	return 1; 
}


# ghosts nee 


###########
# The Learning Rules for Ghosts
#
# A set of rules govorn how new information is learned from an outside source.
# All truth state merger information happens here. The core rules have been worked
# out in a mini-proof in the CONCEPTS.txt document. 
#
# RULE #1: A stat can never be older than the hash in a given ghost. 
# Cause for immediate program termination.
# 
# RULE #2: Two peices of information with the same date must be the same, otherwise ERROR
# 
# RULE #3: The date corresponding to the size is lockstep with the date on rest of the stat. Correlary -- all stat information must travel together
# 
# RULE #4: A new provided hash will be accepted into a learner as long as its date 
# is newer than both the hash and the stat
# 
# RULE #5: A new stat that represents a change in size should invalidate the
# existing hash, unless the hash has the exact same date as the stat. (If the existing
# hash is newer than the incoming stat, but older than the existing stat, we
# have a logical violation of RULE #1)
#
# RULE #6: New stat overrides old stat
#
# RULE #7: A dead stat (ERR) always revokes the hash and blanks out size and XXX

# Policy: same information with a new date does not normally force dirtyness
# unless it is a hash, because the hash is expensive
#
use Data::Dumper;



sub learnFromGhost
{
	my $self = shift; 
	my $g = shift;

	main::debugLevel(1);

	die unless ref $g; 

	if($provenanceDebug)
	{
		my $gid = $g->debugID();
		$self->addDebugProvenance( "learn($gid)" );
		my $gid2 = $self->debugID();
		$g->addDebugProvenance( "teach($gid2)" );
	}



	CODEPATH( "ghost merging" );

	if( $learnDebug )
	{
		debug "++++++++++++++++++++++++++++++++++ Base Ghost\n";
		$self->printDebug();
		debug "++++++++++++++++++++++++++++++++++ Teaching Ghost\n";
		$g->printDebug();
		debug "++++++++++++++++++++++++++++++++++ END\n";
	}

	#print Dumper( $self );
	main::debugLevel(1);

	die if defined $g->effectiveDate() and $g->effectiveDate() > time();

	my $sequence = $self->sequence();

	if( defined $g->sequence() )
	{
		if( not defined $self->sequence() )
		{
			# i must not be dirty 
			die "assert" if $self->dirty();
			$self->sequence( $g->sequence() );
			# this next call will ensure that the sequence number is bumped.
			debug "Learn: Sequence Assigned" if $learnDebug;
			$self->markDirty( $g->effectiveDate(), "seq");
		}
		else
		{
			# I want to be equal to or greater than the other ghost unless I
			# am already dirty, in which case bump one more.
			if( $self->dirty() )
			{
				if( $g->sequence() >= $self->sequence )
				{
					$self->sequence( $g->sequence() + 1 );
				}
			}
			else
			{
				if( $g->sequence() >= $self->sequence )
				{
					$self->sequence( $g->sequence() );
				}
			}
		}
	}

	# learn UUID if we don't already have one

	if( defined $g->uuid() and !defined $self->uuid() )
	{
		$self->uuid( $g->uuid() );
		debug "Learned - UUID" if $learnDebug;
		$self->markDirty( $g->effectiveDate(), "uuid");
	}


	# not clear if this semanitic is right. How do we know the new ghost
	# actually has the same underlying contents? You could argue that a
	# learnFromGhost shouldn't populate this unless it also is learning its
	# children.

	# if( defined $g->lastEnumerated() )
	# {
	# 	$self->learnEnumerated( $g->lastEnumerated() )
	# }

	# if( defined $g->sequence() and !defined $self->sequence() )
	# {
	# 	$self->sequence( $g->sequence() );
	# 	debug "Learned - Sequence" if $learnDebug;
	# 	$self->markDirty();
	# }

	#print Dumper( $self );


	if( defined $g->lastStat() )
	{
		my $size = $g->size();
		my $mode = $g->mode();
		my $mtime = $g->mtime();
		my $statStruct = $g->statStruct();

		$self->learnStat( $g->lastStat(), $size, $mtime, $mode, $statStruct );
	}

	if( defined $g->lastFullHash() )
	{
		my $hash = $g->fullHash();
		$self->learnFullHash( $g->lastFullHash(), $hash );
	}

	# if after all of this stuff above we are still somehow not >= to the
	# target's effective date, something could be wrong. But it could just be
	# that a new ghost was created that never learned anything useful in its
	# life and has an effective date merely by virtue of having a newer
	# creation date.

	if( defined $g->effectiveDate() )
	{
		if( defined $self->effectiveDate() )
		{
			if( $self->effectiveDate() < $g->effectiveDate() )
			{
				CODEPATH( "Learner older than teacher - warning");
				# seems to be more common now that we are using learn
				# semantics to push and pull data out of all external sources
				# maybe this warning isn't as important


				# warn "Strange case where student ghost is older effective";
				# print "WARN: Self:\n";
				# $self->printDebug();
				# print "WARN: Teacher:\n";
				# $g->printDebug();
				# die "Internal assert - doesn't seem right to not be one step ahead of target";
			}
		}
		else
		{
			# this is a impossible situation - if we had no effectiveDate,  it
			# means we know noththing. I can't think of any good reason why
			# leearn on an effective date bearing ghost would not mark as
			# dirty.

			die "How did we learn nothing from the target? suspicious!";
		}
	}

	if( defined $g->lastDeepScan() )
	{
		$self->learnDeepScan( $g->lastDeepScan(), $g->deepSize(), $g->deepCount );
	}


	main::debugLevel(-1);

	if( $learnDebug )
	{
		debug "++++++++++++++++++++++++++++++++++ Final Ghost\n";
		$self->printDebug();
		debug "++++++++++++++++++++++++++++++++++ END\n";
	}

	#print Dumper( $self );

	main::debugLevel(-1);

}


sub flush
{
	my $self = shift;

	TruthKeeper::get()->saveGhostToStore( $self );
}



# Should undelete the file

sub learnPresent
{
	my $self = shift;
	my $time = shift; 

	$self->verifyGhostIsMutable();

	# TODO: implement field
}

sub max
{
	my $a = shift;
	my $b = shift;

	return $a if not defined $b; 
	return $b if not defined $a; 

	return $a if $a > $b;
	return $b; 
}

sub markDirty
{
	my $self = shift;
	my $date = shift;
	my $provenance = shift;

	die unless defined $date; 

	$self->addDebugProvenance( "d[$provenance]") if $provenanceDebug;

	if( not defined $self->dirty() or ($self->dirty() == 0 ))
	{
		# print "***** First time dirty record\n";

		# not sure this all will still work. 

		if( defined $self->sequence() )
		{
			$self->sequence( $self->sequence() + 1 );
		}
		else
		{
			$self->sequence( 0 );
		}

		if( not defined $self->uuid() )
		{
			my $datestr = POSIX::strftime( "%Y%m%d-%H%M%S", localtime() );
			$self->uuid( "uuid-$$-$datestr")
		}
	}
	$self->dirty(1);

	my $newEff = max( $date, $self->effectiveDate() );

	$self->effectiveDate( $newEff );

	$self->{_onceWasDirty} = 1; 

	if( $learnDebug )
	{
		my $gid = $self->debugID();
		debug "Ghost ($gid) marked dirty ($provenance) date:($date)";
	}
}

# Used for a _gfslog facility that is experimental for testing and learning purposes

sub everWasDirtyThisRun
{
	my $self = shift; 
	return 1 if( exists $self->{_onceWasDirty} );
	return 0;
}



# Dirscan means that we have seen the ghost in a directory scan
# TODO also update a "firstSeen" field.
# If deleted, this should undelete by delegating to learnPresent

sub learnDirscan
{
	my $self = shift;
	my $time = shift; 

	$self->verifyGhostIsMutable();

	$self->lastDirScan( $time );

	# TODO: Do we want a dirscan to always force an update to the ghost?
	# With this next line commented out, a new directory scan will not by itself
	# force an update
	# $self->markDirty()

	$self->learnPresent( $time );
}



# This tells the ghost that as far as GFS knows, this ghost is actually a copy
# of another ghost. 

sub learnIsACopyOfGhost
{
	my $self = shift;
	my $g = shift;




	# clear out anything that might confuse the stat
	$self->lastFullHash(undef);
	$self->lastStat(undef);

	$self->learnFromGhost( $g );

	# and furthemore, void out the dates

	# experimental
	$self->lastFullHash(undef);
	$self->lastStat(undef);

}



# This tells the ghost that the file contents are presumed to have changed. In
# fact, the file may not exist anymore. For consistency, we basically pretend
# that the file doesn't exist anymore, thus forcing recalculations.
# hasAcceptableXXX() will always return false in these cases.

# TODO: is a cleaner way to do this to have some sort of "knownUpdate" field
# that is triggered on it which automatically fails out the next hasAcceptable() 

# This function should ALWAYS be called if the signature of the file has
# changed, so that it can propgate that information up the tree.


sub learnContentsChanged
{
	my $self = shift;
	my $time = shift;

	die unless defined $time; 

	if( (not defined $self->lastChanged() ) or ($self->lastChanged() < $time ))
	{
		debug " XX learnContentsChanged() called - checking revokes " if $revokeDebug || $learnDebug;

		if( defined $self->lastStat() && $self->lastStat() < $time )
		{
			$self->size( undef );
			$self->mtime( undef );
			$self->lastStat( undef );
			$self->statStruct( undef );
			$self->mode( undef );
			debug " XX Revoking statfields due to learnContentsChanged()" if $revokeDebug || $learnDebug;
			$self->markDirty( $time, "cc/stat");
		}

		if( defined $self->lastFullHash() && $self->lastFullHash() < $time )
		{
			$self->fullHash( undef );
			$self->lastFullHash( undef );
			debug " XX Revoking hash due to learnContentsChanged()" if $revokeDebug || $learnDebug;
			$self->markDirty( $time, "cc/hash");
		}

		if( defined $self->lastDeepScan() && $self->lastDeepScan() < $time )
		{
			$self->deepSize( undef );
			$self->deepCount( undef );
			debug " XX Revoking deep fields due to learnContentsChanged()" if $revokeDebug || $learnDebug;
			$self->markDirty( $time, "cc/deep");
		}

		# Optimization possible - don't do this if existing lastChanged is less than X seconds ago
		# to prevent repeated walks up the tree;

		$self->lastChanged( $time );
		$self->markDirty( $time, "cc+");
		
		debug " XX learnContentsChanged() - scanning parents" if $revokeDebug || $learnDebug;

		if( $self->exists() )
		{
			debug " Node exists, lets look for parent..";
			my $plfn = $self->getParentLFN();

			if( ! defined $plfn )
			{
				debug "I am the root, LCC over.";
				return;
			}

			my $tk = TruthKeeper::get();
			my $parent = $tk->obtainGhostForLFN($plfn);

			if( $parent->exists() )
			{	
				$parent->learnContentsChanged( $time );
				$parent->flush();
			}
		}
	}
	else
	{
		debug "notifyContentsChanged - Skipping since node appears up to date" 
			if $revokeDebug || $learnDebug;
	}
}


sub getParentLFN
{
	my $self = shift;

	my $lfn = $self->lfn();

	debug "Searching for parent of [$lfn]";

	if( $self->canHaveChildren() )
	{
		my $plfn =  $self->getFSE()->getParentLFN( $self );
		debug "   Parent is:[$plfn] (case1)";
		return $plfn; 
	}
	else
	{
		 my $plfn = $self->getFSE()->getContainingDirLFN( $self );
		 debug "   Parent is:[$plfn] (case2)";
		return $plfn; 
	}
	
}

sub fullHash
{
	my $self = shift;
	#my $r = $self->SUPER::fullHash(@_);
	my $x = $self->_fullHash();
	my $l  = @_;
	my $lfn = $self->lfn();
	#print "NEW HASH TAKEN LFN[[$lfn]] $self ($x) at:[@_] l:$l \n";
	#cluck "corner case found!!!!" if $l > 0 and not defined $_[0] ; 

	#print Dumper( $self );

	return $self->_fullHash( @_ );
}

# This is the universal way of reporting new stat information, either from the
# disk, or from another ghost. It adjudicates what information to keep and
# what to toss using the set of rules worked out above. 

sub learnStat
{
	my $self = shift;
	my $time = shift;

	die if $self->isImmutable();

	die "learnStat() did not get a time argument" unless defined $time;
	die "incoming information newer than current time ($time)" if $time > time();

	my $size = shift;
	my $mtime = shift;
	my $mode = shift;
	my $statStruct = shift;

	my $sigHasBeenChanged = 0; 

	die "invalid call to learnStat" if defined $statStruct and not ref $statStruct;

	my $q = $self->quickDebugString();

	if( $learnDebug )
	{
		my $__size = defined $size ? $size : "<undef>";
		my $__mtime = defined $mtime ? $mtime : "<undef>";
		my $__mode = defined $mode ? $mode : "<undef>";
		my $__statStruct = defined $statStruct ? $statStruct : "<undef>";
		debug "LEARN STAT [$__size], [$__mtime], [$__mode] [$__statStruct] for $q time:[$time]\n" if $learnDebug;
		$self->printDebug();
	}


	# RULE3: ALl stat informaiton must travel together. 

	die "learn() got partial stat (violates RULE#3)" if not defined $mode;

	if( not main::statModeParse_isError( $mode ) )
	{
		die "learn() got partial stat (violates RULE#3)" if not defined $size;
		die "learn() got partial stat (violates RULE#3)" if not defined $mtime;
	}

	$self->verifyGhostIsMutable();

	# RULE1: t(stat) > t(hash) 
	# We may learn about a stat done after a hash

	if( (defined $self->lastFullHash()) && 
		($time < $self->lastFullHash()) &&
		($time > $self->lastStat() ))
	{

		warn "ERROR case where last full hash  > time (time=$time)";
		print "WARN: Self:\n";
		$self->printDebug();

		die "RULE 1: RULE1: t(stat) > t(hash) or BOMB";
	}

	# RULE2: incoming information with same date as existing information must be same

	if( (defined $self->lastStat()) and ($time == $self->lastStat() ))
	{

		die "Rule2: same date mismatch A" if defined $size  and defined $self->size()  and $self->size() != $size;
		die "Rule2: same date mismatch B: $mtime vs " . $self->mtime()
			 if defined $mtime and defined $self->mtime() and $self->mtime() != $mtime;
		die "Rule2: same date mismatch C" if defined $mode  and defined $self->mode()  and $self->mode() ne $mode;
		# its okay for stat structs to differ slightly


		die "Rule2: same date mismatch E" if defined $size  and not defined $self->size(); 
		die "Rule2: same date mismatch F" if defined $mtime and not defined $self->mtime();
		die "Rule2: same date mismatch G" if defined $mode  and not defined $self->mode();
		die "Rule2: same date mismatch H" if defined $statStruct  and not defined $self->statStruct();
	}

	# older data is silently ignored.

	if( (defined $self->lastStat()) and ($time < $self->lastStat() ))
	{
		CODEPATH( "ignored older incoming stat" );
		return;
	}


	# RULE #6: Error stats revoke all other fields

	if( main::statModeParse_isError( $mode ) )
	{
		if( defined $self->mode() and main::statModeParse_isError( $self->mode() ))
		{
			debug( " XX Revoked hash due to error mode=($mode) for $q") 
				if $revokeDebug || $learnDebug;

			$self->lastFullHash(undef);
			$self->fullHash(undef);
			$sigHasBeenChanged  = 1;

			CODEPATH( "revoke hash due to stat error" );		

		}
	}

	# RULE #5: A new stat that represents a change in size should invalidate the
	# existing hash, unless the hash has the exact same date as the stat. (If the existing
	# hash is newer than the incoming stat, but older than the existing stat, we
	# have a logical violation of RULE #1)

	if( (defined $self->size()) && ((not defined $size) or ($self->size() != $size)))
	{
		$sigHasBeenChanged = 1;

		$self->lastFullHash(undef);
		$self->fullHash(undef);

		debug( " XX Revoked hash due to new size for $q") if $revokeDebug || $learnDebug;

		CODEPATH( "revokehash with new size" );
	}


	my $anythingHasChanged = 0;

	if( 
		(not defined $self->lastStat()   ) or 
		(not defined $self->size()       ) or 
		(not defined $self->mtime()      ) or 
		(not defined $self->mode()       ) or
		(not defined $self->statStruct() )
		)
	{
		debug "Change = formerFieldsUndefined" if $learnDebug;
		$anythingHasChanged = 1; 
	}
	else
	{
		$anythingHasChanged = 1 if( ( not defined $size  ) and ( defined $self->size()  ) );
		$anythingHasChanged = 1 if( ( not defined $mtime ) and ( defined $self->mtime() ) );
		$anythingHasChanged = 1 if( ( not defined $mode  ) and ( defined $self->mode()  ) );
		$anythingHasChanged = 1 if( ( not defined $statStruct  ) and ( defined $self->statStruct()  ) );

		$anythingHasChanged = $sigHasBeenChanged = 1 if( defined $size and $self->size() != $size );
		$anythingHasChanged = $sigHasBeenChanged = 1 if( defined $mtime and $self->mtime() != $mtime );
		$anythingHasChanged = $sigHasBeenChanged = 1 if( defined $mode and $self->mode() ne $mode );
		$anythingHasChanged = $sigHasBeenChanged = 1 if( defined $statStruct and $self->statStruct()->hasMeaningfullyChanged( $statStruct ) );
	}

	if( (defined $self->lastStat()) and ($time > $self->lastStat() ))
	{
		CODEPATH( "Newer stat information accepted");

		# COntroversial - decision is not to force dirtiness in cases where
		# nothing has changed even though technically we have a newer stat
		# date - means we will do a write of a stat even if nothing has
		# changed in a long time, bumping sequence number etc.
		# If some other field changes, we'll flush the data out, but lastStat alone wont do it. 

		my $ls = $self->lastStat();
		my $diff = $time - $ls; 
		print "$time - $ls = $diff > $main::GUARD_TIME_SECONDS_STAT\n";

		if( $time - $self->lastStat() > $main::GUARD_TIME_SECONDS_STAT )
		{
			$anythingHasChanged = 1; 
		}
	}	

	$self->size($size);
	$self->mtime($mtime);
	$self->mode($mode);
	$self->statStruct($statStruct);

	$self->lastStat( $time );

	if(( $anythingHasChanged == 0 ) and ($time > $self->lastStat() ))
	{
		CODEPATH( "newer stat did not mark dirty, corner case" );
	}

	debug "Learn STAT: isAnythingChanged? $anythingHasChanged   hasSigChanged? $sigHasBeenChanged"
	if $learnDebug; 	

	$self->markDirty( $time, "stat") if $anythingHasChanged;

	if( $sigHasBeenChanged )
	{
		$self->learnContentsChanged( $time );
	}

}

# learning routines should not themselves trigger active checks. 


sub canHaveChildren__learnSafe
{
	my $self = shift;
	my $type = $self->type();

	die if( not defined $type );

	# debug "Type is: $type\n";
	# base case: no knowledge or hash

	if( $type eq 'd' )
	{
		return 1;
	}

	return 0;

}

sub learnFullHash
{
	my $self = shift;
	my $time = shift;
	my $hash = shift;

	die if $self->isImmutable();

	my $q = $self->quickDebugString();

	my $hasSigChanged = 0;

	if( $learnDebug )
	{
		my $__time = defined $time ? $time : "<undef>";
		my $__hash = defined $hash ? $hash : "<undef>";
		debug "LEARN HASH time:[$__time] hash:[$__hash] for $q\n";
		$self->printDebug();
	}

	die unless defined $time;
	die unless defined $hash;

	die "incoming information newer than current time ($time)" if $time > time();

	$self->verifyGhostIsMutable();

	# RULE 1: A stat can never be older than the hash in a given ghost (unless it is a directory)

	if( (defined $self->lastFullHash()) and 
		(defined $self->lastStat()) and
		(! $self->canHaveChildren__learnSafe() ) and 
		($time > $self->lastStat() ))
	{	
		warn "ERROR case where last full hash  > time (time=$time)";
		print "ERRR: Self:\n";
		$self->printDebug();

		die "stat cannot be older than hash (assert)" unless $self->lastFullHash() <= $self->lastStat();
	}	

	# Check rule 1 and rule 2

	if( defined $self->lastFullHash() )
	{
		# RULE 1: A stat can never be older than the hash in a given ghost

		if( (! $self->canHaveChildren() ) and
			($self->lastFullHash() < $time) and 
			($self->lastStat() < $time ))	
		{	
			die "stat cannot be older than hash";
		}
	
		# Rule 2: New information with same date must be same information

		if( $self->lastFullHash() == $time && !$self->canHaveChildren__learnSafe() )
		{
			if( $self->fullHash() ne $hash )
			{

				my $x = $self->fullHash();
				print "I was supposed to learn hash:$hash for time $time\n";
				print "But I have hash $x at the same time\n";

				die "Rule 2 violation";
			}
		}
	}

	# Avoid doing anything if the hash is older

	if( (defined $self->lastFullHash()) and ($time < $self->lastFullHash() ))
	{
		CODEPATH( "Ignored older hash");
		return; 
	}	

	# At this point, we're convinced the new data is valid, but the qeuestion
	# is if its new enough to incorporate.

	my $isAnythingChanged = 0; 

	if( (defined $self->fullHash()) and ($hash ne $self->fullHash() ))
	{
		CODEPATH( "Newer hash information accepted"); 

		$hasSigChanged = 1;

		my $lfn = $self->lfn();
		my $ch = $self->fullHash();
		print "************************************************ CHANGE!!!\n";
		print "  LFN: $lfn\n";
		print "  NEW: $hash\n";
		print "  OLD: $ch\n";



		$isAnythingChanged = 1; 
	}

	if( (defined $hash) and !(defined $self->fullHash()))
	{
		CODEPATH( "First hash information accepted"); 
		$isAnythingChanged = 1; 
	}		

	if( !defined $self->lastFullHash() )
	{
		$isAnythingChanged = 1; 
	}
	elsif( $self->lastFullHash() < $time )
	{
		CODEPATH( "Updated date of full hash"); 
		$isAnythingChanged = 1; 
	}

	$self->lastFullHash( $time );
	$self->fullHash( $hash );

	debug "Accepted hash [$hash]\n" if $learnDebug;;

	debug "Learn HASH: isAnythingChanged? $isAnythingChanged" if $learnDebug; 	

	$self->markDirty( $time, "hash") if $isAnythingChanged;

	if( $hasSigChanged )
	{
		$self->learnContentsChanged($time);
	}
}

# Deleted means that we did not see the ghost on a recent scan. Mark as
# deleted and set deleteDate.

# TODO change semantics, this is not sort of like an confimed negative

sub learnDeleted
{
	my $self = shift;
	my $time = shift; 

	$self->verifyGhostIsMutable();

	$self->lastDirScan( $time );

	# TODO: Do we want a dirscan to always force an update to the ghost?
	$self->markDirty($time, "del");
}

use Fcntl ':mode';

sub extractTypeFromMode
{
	my $self = shift;
	my $mode = shift;

	# die if $mode eq "";
	# die if not defined $mode;
	# print "Mode:: [$mode]\n";

	return undef if( not defined $mode );

	return '_' if main::statModeParse_isError( $mode );

	return 'f' if S_ISREG($mode);
	return 'd' if S_ISDIR($mode);

	return undef;
}

sub isFile
{
	my $self = shift;
	die if not defined $self->getMode();
	return 1 if $self->getType() eq 'f';
}

sub getType
{
	my $self = shift;
	my $mode = $self->getMode();
	return $self->extractTypeFromMode( $mode );
}


sub type
{
	my $self = shift;
	my $mode = $self->mode();
	return $self->extractTypeFromMode( $mode );
}

sub getFullHashSourceVerify
{
	my $self = shift;
	my $time = shift;

	if( $self->canHaveChildren() )
	{
		$self->calculateDeepFields( $time );
		my $fullhash = $self->fullHash();
		return $fullhash;
	}
	else
	{
		my $fullhash = $self->getFSE()->getFullHashSourceVerify( $self, $time );
	 	$self->learnFullHash( $time, $fullhash );
	 	return $fullhash;
	}
}

sub isSameNumberOrDef
{
	my $a = shift;
	my $b = shift;

	#print "[$a] vs [$b]\n";

	if( defined $a )
	{
		if( defined $b )
		{
			return $a == $b;
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 1 if not defined $b;
	}

	return 0;
}

sub isNotSameNumberOrDef
{
	my $a = shift;
	my $b = shift;
	return ! isSameNumberOrDef( $a, $b );
}


sub getStatSourceVerify
{
	my $self = shift;
	my $time = shift; 

	my ($size, $mtime, $mode, $statStruct) = $self->getFSE()->getStatSourceVerify( $self, $time );
 
	$self->learnStat( $time, $size, $mtime, $mode, $statStruct );

	die "assert - somehow a hard stat didn't absorb" if isNotSameNumberOrDef( $self->size(), $size);
	die "assert - somehow a hard stat didn't absorb" if isNotSameNumberOrDef( $self->mtime(), $mtime);
	# modes can be strings or numbers, so no easy assert.
	# die if isNotSameNumberOrDef( $self->mode(), $mode);

	return ( $size, $mtime, $mode );
}

###

package TestEnvironment;

use File::Basename;
use File::Spec;
use File::Path;
use File::Copy;
use Cwd;


sub assert
{
	my $self = shift;
	my $expr = shift;

	die if not ref $self;
	die unless $expr;
}

sub waitForRollover
{
	my $self = shift;

	sleep(1);
}

sub go
{
	my $class = shift;

	my $te = TestEnvironment->new("hashrevoke");
	$te->clear();
	$te->mkdirs( "/tmp/gfstest" );
	$te->mkdirs( "/tmp/gfstest/dir-a/" );

	$te->mkfile( "/tmp/gfstest/dir-a/file1", 12 );	
	$te->mkfile( "/tmp/gfstest/dir-a/file2", 14);	
	system( "cp -rv /tmp/gfstest/dir-a /tmp/gfstest/dir-b");

	$te->gfsrun( '--chdir /tmp/gfstest checkpoint . -G 0 ');
	my $r1 = $te->gfsrun( '--chdir /tmp/gfstest --debug-dump checksum-single dir-a/file1 ');
	my $r2 = $te->gfsrun( '--chdir /tmp/gfstest --debug-dump checksum-single dir-b/file1 ');
	$te->assert( $r1->{run}->{getFullHash} eq $r2->{run}->{getFullHash} );
	$te->waitForRollover();

	$te->mv( "/tmp/gfstest/dir-b/file1", "/tmp/gfstest/dir-b/file1-renamed" );
	$te->mv( "/tmp/gfstest/dir-b/file1", "/tmp/gfstest/dir-b/file2-renamed" );

	$te->gfsrun( '--chdir /tmp/gfstest checkpoint . -G 0');

	$te->gfsrun( '--chdir /tmp/gfstest debug dbtest');

	exit(0);


}

sub gfsrun
{
	my $self = shift;
	my @c = @_;

	my $runPrefix = "/tmp/gfsrun";
	my $TESTSTATE_LASTRUN_STD = "$runPrefix.stdout";
	my $TESTSTATE_LASTRUN_ERR = "$runPrefix.stderr";

	my $cmd = "gfs @c  > $TESTSTATE_LASTRUN_STD 2> $TESTSTATE_LASTRUN_ERR";
	print "RUN:[$cmd]\n";
	system($cmd );

	if ($? == -1) {
	   die "failed to execute: $!\n";
	}
	elsif ($? & 127) {
	   die "child died with signal %d, %s coredump\n",
	       ($? & 127),  ($? & 128) ? 'with' : 'without';
	}
	else {
	   printf "child exited with value %d\n", $? >> 8;
	   die unless $? >> 8 == 0;
	}




	{
		local $/ = undef;
		local *FILE;
		open FILE, "<$TESTSTATE_LASTRUN_STD";
		# $TESTSTATE_LAST_OUTPUT = <FILE>;
		close FILE;
	}

	my $buff = undef;

	if( -e '/tmp/gfsLast.dump' )
	{
		local $/ = undef;
		local *DUMP;
		open DUMP, "</tmp/gfsLast.dump" or die "Cannot read it";
		$buff = <DUMP>;
		close DUMP;
	}

	$self->rm( '/tmp/gfsLast.dump' );

	# print $buff;

$Data::Dumper::Terse=1;
my $VAR1;
eval  $buff ;

	return  $VAR1;
}

sub clear
{
	my $self = shift;
	system( 'rm -r /tmp/gfstest/' );
}

sub new
{
	my $class = shift;
	my $self = {};
	bless $self, $class;
	return $self; 
}

sub mkdirs($)
{
	my $self=shift;
	my $dir = shift;

	# my $dirx = dirname $dir;

	# print "MKDIRS:[$dir]\n";
	mkpath( $dir );
	$@ and die "Couldn't create dir path [$dir]: $! $@";
	die "Did not find new path [$dir]" if not -d $dir;

	return 1;
}



sub mkfile($$)
{
	my $self = shift; 

	my $path = shift;
	my $seed = shift;

	my $TESTSTATE_TEST_NAME= $self->{TESTSTATE_TEST_NAME};

	#mkdirs(dirname($path) );

	open FILE, ">$path" or die "Cannot open $path: $!";
	print FILE "X-$seed" x 100;
	close FILE;

	die unless -e $path;

	$self->{shaForSeed}->{$seed} = $self->getTrueSHA( $path );

	print "$TESTSTATE_TEST_NAME - mkfile - $seed - $path\n";

}

sub getTrueSHA
{
	my $self = shift;
	my $path = shift;
	my $sha = `shasum $path`;
	chomp $sha; 
	($sha =~ /^([^\s]+)\s/ ) or die;
	my $r = $1; 
	chomp $r;
	return $r;
}

use File::Copy;

sub mv
{
	my $self = shift;

	my $a = shift;
	my $b = shift;

	my $TESTSTATE_TEST_NAME= $self->{TESTSTATE_TEST_NAME};
	File::Copy::move( $a, $b );

	print "$TESTSTATE_TEST_NAME - mv - $a -> $b\n";
}

sub rm
{
	my $self = shift;
	my $a = shift;
	my $TESTSTATE_TEST_NAME= $self->{TESTSTATE_TEST_NAME};
	unlink( $a );

	print "$TESTSTATE_TEST_NAME - rm - $a\n";
}




###



main::main();
exit();

