#!/usr/bin/perl

use Digest::SHA;
use File::Basename;
use File::Spec;

use strict;

my $DESCRIPTOR_FILENAME = "00descriptor.gfs";

local $main::run_files_fullread = 0;
local $main::run_descriptors_read = 0;

sub main()
{
	print "Welcome to Ghost.\n";

	my $verb = shift @ARGV;

	print " Verb = [$verb]\n";

	if( $verb eq "info" )
	{
		doverb_info();
	}

	# LS tells us what we can find out about the current directory tree
	# nothing is force read, only stat'ed

	if( $verb eq "ls" )
	{
		doverb_ls();
	}


	# Takes the listed things and writes a single descriptor file

	if( $verb eq "write-descriptor")
	{
		doverb_writeDescriptor();
	}

	# Basically a test verb used to prove that serialization and deserialization are identical

	if( $verb eq "copyDescriptor" )
	{
		my $src = shift @ARGV;
		my $d = shift @ARGV;

		my $store = GhostStore->new();
		$store->slurpDescriptor( $src);
		$store->writeAsDescriptor( $d );
	}

	print "Full reads: $main::run_files_fullread\n"

}


sub getGhostDescriptorFileForLFN($)
{
	my $filename = shift;

	my( $fn, $dir ) = fileparse( $filename );

 	my $dfn = File::Spec->catfile($dir, $DESCRIPTOR_FILENAME);

	return $dfn;
}

sub doverb_ls()
{
	my $store = GhostStore->new();

	foreach my $lfn (@ARGV)
	{
		my $dfn = getGhostDescriptorFileForLFN($lfn);

		print "Pulling in any descriptor for [$lfn] -> [$dfn]\n";

		$store->slurpDescriptor( $lfn );

		# First look for a ghost from the descriptor file
		# call getGhostDescriptorFileForLFN()
		# if there is a desccriptor, load it

		# we have a ghostStore gs
		# slurp all of the descriptors into the gs object
		# the interate over the the files and print out what we know

		# slurping means we need to de-duplicate

	}

}


sub doverb_writeDescriptor()
{
	my $store = GhostStore->new();
#	$store->slurpDescriptor( "GhostDescriptors.out" );


	my $fse = new FilesystemExplorer();
	$fse->setRoots( @ARGV );

	while( defined(  my $file = $fse->next() ) )
	{
		print "Scanned $file\n";


	}


}

sub doverb_info()
{

	my $store = GhostStore->new();
	$store->slurpDescriptor( "GhostDescriptors" );

	foreach my $lfn (@ARGV)
	{
		print( "Info request for: $lfn\n");
		my $g = Ghost->make( $lfn );
		my $h = $g->getFullHash();
		print("    $h\n");

		$store->addGhost( $g );
	}	

	$store->writeAsDescriptor( "GhostDescriptors" );


}



sub getFullHash($)
{
	## TODO - implement without full slurp

	my $lfn = shift;

	my $sha = Digest::SHA->new(1);
	$sha->addfile( $lfn );
	my $hexdigest = $sha->hexdigest();

	$main::run_files_fullread++;

	return( "SHA1/FULL/$hexdigest");

}






package FilesystemExplorer;

use base qw(Class::Accessor);
FilesystemExplorer->mk_accessors( qw(topLevelLFNs queue) );

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();

	return $self;
}


sub setRoots()
{
	my $self = shift;

	$self->topLevelLFNs( [@_] );
	$self->queue( [@_] );
}

sub scanDir
{
	my $self = shift;
	my $dir = shift;

	my $q = $self->queue();	

	#print "Scanning into $dir\n";

	opendir DIR, $dir;

	# drop . and .., sort directory
	my @files = map { $dir.'/'.$_ } grep { !/^\.{1,2}$/ } sort { $a cmp $b } readdir DIR;

	# print( "Got: ", (join ':', @files ), "\n" );

	close DIR;

	unshift @$q, @files;
	unshift @$q, \"Thunk";
}


# returns the next directory

sub next
{
	my $self = shift;

	my $n = $self->nextRaw();

	if( ref $n )
	{
		print "THUNK received...";
		return $self->next();
	}

	return $n;
}


sub nextRaw
{
	my $self = shift;

	my $q = $self->queue();

	my $c = shift @$q;

	if( not defined $c )
	{
		return undef; 
	}

	# print "Got[$c]\n";

	# if the next thing is a directory, scan into the directory
	if( -d $c )
	{
		$self->scanDir( $c );
	}

	return $c;
}



package GhostStore;

use base qw(Class::Accessor);
GhostStore->mk_accessors( qw(lfnToGhost) );

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();
	$self->lfnToGhost( +{} );

	return $self;
}

sub addGhost($)
{
	my $self= shift;
	my $g = shift;

	my $lfnToGhost = $self->lfnToGhost();

	# Do the incorporation here
	# the major caching form is by localname which is assumed to be unique
	# there should only be one ghost per LFN

	if( exists $lfnToGhost->{$g->lfn()} )
	{
		# merge case
		# take the best of both
		# prefer checksum from the newer one
		# use that for the date of the hash

		my $base = $lfnToGhost->{$g->lfn()};

		if( $base->lastFullHash() < $g->lastFullHash() )
		{
			$base->lastFullHash( $g->lastFullHash() );
			$base->fullHash( $g->fullHash() );

			print "  -  Merger case - old wins";
		}
		else
		{
			print "  -  Merger case - new wins";
		}
	}
	else
	{
		$lfnToGhost->{$g->lfn()} = $g; 
	}
}

sub slurpDescriptor($)
{
	my $self = shift;
	my $fn = shift;

	open( FILE, "<$fn") or die "Cannot open $fn to read descriptor";

	while( <FILE> )
	{
		chomp;
		print "Slurping: $_\n";
		my $g = Ghost->newFromSerialized( $_ );
		$self->addGhost( $g );
	}

	close( FILE );
}


sub writeAsDescriptor($)
{
	my $self = shift;
	my $fn = shift;


	my $lfnToGhost = $self->lfnToGhost();


	open( FILE, ">$fn") or die "Cannot open $fn to write descriptor";

	foreach my $g ( values %$lfnToGhost )
	{
	
		print FILE $g->serialize();
		print FILE "\n";
	}

	close( FILE );
}


package Ghost;

use base qw(Class::Accessor);
Ghost->mk_accessors( qw(lfn lastFullHash fullHash ) );

sub newFromSerialized($)
{
	my $class = shift;
	my $str = shift;

	my $self = Ghost->new();

	my @a = split ':', $str;

	$self->lfn( shift @a );
	$self->lastFullHash( shift @a );
	$self->fullHash( shift @a );

	return $self;

}

sub serialize()
{
	my $self = shift;

	# TODO: Add proper escapes

	my @s = ( $self->lfn(), 
			  $self->lastFullHash(),
			  $self->fullHash()
			  );

	my $s = join ':', @s;

	return $s;
}

sub make($)
{
	my $class = shift;
	my $lfn = shift;

	my $self = $class->new();

	print "Making Ghost for lfn=[$lfn]\n";
	$self->lfn( $lfn );
	return $self;
}


sub getFullHash
{
	my $self = shift;
	my $lfn = $self->lfn();

	$self->lastFullHash( time() );


 	my $fullhash = main::getFullHash( $lfn );

	$self->fullHash( $fullhash );

	return $fullhash;
}


###

main::main();
exit();



