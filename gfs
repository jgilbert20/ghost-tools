#!/usr/bin/perl

use Digest::SHA;
use File::Basename;
use File::Spec;

use strict;

my $DESCRIPTOR_FILENAME = "00descriptor.gfs";

local $main::run_files_fullread = 0;
local $main::run_descriptors_read = 0;
local $main::run_descriptors_write = 0;

sub main()
{
	print "Welcome to Ghost.\n";

	my $verb = shift @ARGV;

	print " Verb = [$verb]\n";

	if( $verb eq "info" )
	{
		doverb_info();
	}

	# LS tells us what we can find out about the current directory tree
	# nothing is force read, only stat'ed

	if( $verb eq "ls" )
	{
		doverb_ls();
	}


	# Takes the listed things and writes a single descriptor file

	if( $verb eq "write-descriptor")
	{
		doverb_writeDescriptor();
	}

	# Basically a test verb used to prove that serialization and deserialization are identical

	if( $verb eq "copyDescriptor" )
	{
		my $src = shift @ARGV;
		my $d = shift @ARGV;

		my $store = GhostStore->new();
		$store->slurpDescriptor( $src);
		$store->writeAsDescriptor( $d );
	}

	print "Full reads: $main::run_files_fullread\n";
	print "Desc reads: $main::run_descriptors_read\n";
	print "Desc wrtes: $main::run_descriptors_write\n";

	flushGhostDescriptorCache();


}


sub getGhostDescriptorFileForLFN($)
{
	my $filename = shift;

	my( $fn, $dir ) = fileparse( $filename );

 	my $dfn = File::Spec->catfile($dir, $DESCRIPTOR_FILENAME);

 	print "GDF [$dfn] for $filename\n";

	return $dfn;
}

sub doverb_ls()
{
	my $store = GhostStore->new();

	foreach my $lfn (@ARGV)
	{
		my $dfn = getGhostDescriptorFileForLFN($lfn);

		print "Pulling in any descriptor for [$lfn] -> [$dfn]\n";

		$store->slurpDescriptor( $lfn );

		# First look for a ghost from the descriptor file
		# call getGhostDescriptorFileForLFN()
		# if there is a desccriptor, load it

		# we have a ghostStore gs
		# slurp all of the descriptors into the gs object
		# the interate over the the files and print out what we know

		# slurping means we need to de-duplicate

	}

}


sub doverb_writeDescriptor()
{
	my $store = GhostStore->new();

	my $fse = new FilesystemExplorer();
	$fse->setRoots( @ARGV );

	while( defined( my $file = $fse->next() ) )
	{
		print "Verb WD - Scanning: [$file]\n";

		if( -f $file )
		{
			my $fullHash = $fse->getFullHash( $file );
			print "Verb WD: fullhash = $fullHash\n";
		}
		else
		{
			print "Verb WD - Not a regular file: [$file]\n";
		}

	
	}
}

sub doverb_info()
{
	my $store = GhostStore->new();
	$store->slurpDescriptor( $DESCRIPTOR_FILENAME  );

	foreach my $lfn (@ARGV)
	{
		print( "Info request for: $lfn\n");
		my $g = Ghost->make( $lfn );
		my $h = $g->getFullHashForceHitDisk();
		print("    $h\n");

		$store->addGhost( $g );
	}	

	$store->writeAsDescriptor( $DESCRIPTOR_FILENAME );
}



sub getFullHashForceHitDisk($)
{
	## TODO - implement without full slurp

	my $lfn = shift;

	my $sha = Digest::SHA->new(1);
	$sha->addfile( $lfn );
	my $hexdigest = $sha->hexdigest();

	$main::run_files_fullread++;

	return( "SHA1/FULL/$hexdigest");

}

my %ghostStoreForDescriptorLFN;

sub flushGhostStoreLFNCacheEntry
{
	my $lfn = shift;

	print "Flushing ghoststore [$lfn] to disk\n";

	if( not exists $ghostStoreForDescriptorLFN{$lfn} )
	{
		die "Internal assert - $lfn not found";
	}

	my $gs = $ghostStoreForDescriptorLFN{$lfn};

	if( $gs->clean() )
	{
		print "   -- clean flag set\n";
	}
	else
	{
		print "   -- clean flag not set, write needed\n";
		$gs->writeAsDescriptor( $lfn );

	}	

	delete $ghostStoreForDescriptorLFN{$lfn};

	return undef; 
}

sub flushGhostDescriptorCache
{
	foreach my $lfn (keys %ghostStoreForDescriptorLFN )
	{
		flushGhostStoreLFNCacheEntry( $lfn );

	}
}

sub getGhostStoreForDescriptorFileCoveringFN
{
	my $lfn = shift;

	my $gsfn = getGhostDescriptorFileForLFN( $lfn );

	if( exists $ghostStoreForDescriptorLFN{$gsfn} )
	{
		return( $ghostStoreForDescriptorLFN{$gsfn} );
	}
	else
	{
		die "Overflow!" if ((keys %ghostStoreForDescriptorLFN) > 10);

		my $gs = GhostStore->new();

		if( -e $gsfn )
		{
			$gs->slurpDescriptor( $gsfn );
		}

		$ghostStoreForDescriptorLFN{$gsfn} = $gs;

		return $gs;

	}

}


package FilesystemExplorer;

use File::Basename;
use base qw(Class::Accessor);
FilesystemExplorer->mk_accessors( qw(topLevelLFNs queue) );

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();

	return $self;
}

# Caller wants the full hash
# Best place to get it is a descriptor file
# next best place to get it is to hit the disk

sub getFullHash()
{
	my $self = shift;
	my $lfn = shift;

	# TODO error check that this path actual existing in the FSE!

	my $gs = main::getGhostStoreForDescriptorFileCoveringFN($lfn);

	print "FSE - Searching for a fullhash for [$lfn]\n";

	my $g = $gs->findOrMakeGhostByLFN($lfn);

	my $h = $g->getFullHash();

	return $h;
}

sub setRoots()
{
	my $self = shift;

	$self->topLevelLFNs( [@_] );
	$self->queue( [@_] );


	foreach my $f ( @_ )
	{
		if( not -r $f )
		{		
			die "File [$f] is not a readable file or directory"
		}
	}

}

sub scanDir
{
	my $self = shift;
	my $dir = shift;

	my $q = $self->queue();	

	print "FSE:ScanDIR into $dir\n";

	#$dir =~ s/\/+$//;

	opendir DIR, $dir;

	# drop . and .., sort directory
	my @files = map { File::Spec->catfile( $dir, $_ ) } grep { !/^\.{1,2}$/ } sort { $a cmp $b } readdir DIR;

	print( "FSE:ScanDIR Returned: ", (join ':', @files ), "\n" );

	close DIR;

	unshift @$q, \$dir;
	unshift @$q, @files;
	
}


# returns the next directory

sub next
{
	my $self = shift;

	my $n = $self->nextRaw();

	if( ref $n )
	{
		print "THUNK received --> $$n\n";

		# TODO case: 
		# in this case, we have just exited a directory -- may want
		# to purge any contents of descriptors that weren't found

		return $self->next();
	}

	# Check for the end-of-queue case

	if( not defined $n )
	{
		return undef;
	}

	# Now make sure that this isn't something we need to ignore

	print " FSE::getNext() checking [$n]\n";

	my( $fn, $dir ) = fileparse( $n );
 	
	if( $fn eq $DESCRIPTOR_FILENAME )
	{
		print " FSE/next -> skipping descriptor [$fn]\n";

		return $self->next();
	}


	return $n;
}


sub nextRaw
{
	my $self = shift;

	my $q = $self->queue();

	my $c = shift @$q;

	if( not defined $c )
	{
		return undef; 
	}

	# print "Got[$c]\n";

	# if the next thing is a directory, scan into the directory
	if( -d $c )
	{
		$self->scanDir( $c );
	}

	return $c;
}



package GhostStore;

use File::Basename;
use base qw(Class::Accessor);
GhostStore->mk_accessors( qw(lfnToGhost clean) );

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new();
	$self->lfnToGhost( +{} );
	$self->clean(1);

	return $self;
}

sub findOrMakeGhostByLFN
{
	my $self = shift;
	my $lfn = shift;

	my $lfnToGhost = $self->lfnToGhost();


	print "Looking for ghost [$lfn]\n";

	if( exists $lfnToGhost->{$lfn} )
	{
		print "   Found inside ghoststore\n";
		return  $lfnToGhost->{$lfn};
	}
	else
	{

		print( "   Making new ghost for $lfn\n");
		my $g = Ghost->make( $lfn );

		$self->addGhost( $g );
		return $g;
	}



}

sub addGhost($)
{
	my $self= shift;
	my $g = shift;

	my $lfnToGhost = $self->lfnToGhost();

	# Do the incorporation here
	# the major caching form is by localname which is assumed to be unique
	# there should only be one ghost per LFN

	if( exists $lfnToGhost->{$g->lfn()} )
	{
		# merge case
		# take the best of both
		# prefer checksum from the newer one
		# use that for the date of the hash

		my $base = $lfnToGhost->{$g->lfn()};

		if( $base->lastFullHash() < $g->lastFullHash() )
		{
			$base->lastFullHash( $g->lastFullHash() );
			$base->fullHash( $g->fullHash() );

			print "  -  Merger case - old wins";
		}
		else
		{
			print "  -  Merger case - new wins";
		}
	}
	else
	{
		$lfnToGhost->{$g->lfn()} = $g; 
	}

	$self->clean(0);

	return;
}

sub slurpDescriptor($)
{
	my $self = shift;
	my $fn = shift;

	print "Slurping descriptor [$fn]";

	my( $parsedFn, $dir ) = fileparse( $fn );

	my $treebase = $dir; 

	my %seen;

	open( FILE, "<$fn") or die "Cannot open $fn to read descriptor";

	while( <FILE> )
	{
		chomp;
		print "Slurping: $_\n";
		my $g = Ghost->newFromSerialized( $_, treeRoot => $treebase );
		$self->addGhost( $g );

		die "Ghost descriptor contains duplicates - some logic problem!" if( $seen{$g->lfn()}++ > 0 );
	}

	close( FILE );

	$self->clean(1);

	$main::run_descriptors_read++;
}


sub writeAsDescriptor($)
{
	my $self = shift;
	my $fn = shift;

	my $lfnToGhost = $self->lfnToGhost();

	open( FILE, ">$fn") or die "Cannot open $fn to write descriptor";

	foreach my $g ( values %$lfnToGhost )
	{
		print FILE $g->serialize( pathMode => "basename");
		print FILE "\n";
	}

	close( FILE );

	$self->clean(1);

	print "Wrote descriptor -> $fn\n";

	$main::run_descriptors_write++;
}


package Ghost;

use File::Basename;

use base qw(Class::Accessor);
Ghost->mk_accessors( qw(lfn lastFullHash fullHash ) );

sub newFromSerialized($)
{
	my $class = shift;
	my $str = shift;
	my %options = @_;

	my $self = Ghost->new();

	# TODO: Add proper escapes (String::Escape has nice examples)

	my @a = split ':', $str;

	my $serialLFN = shift @a;

	if( defined $options{'treeRoot'} )
	{
		my $root = $options{'treeRoot'};
		# $root =~ s/\/+$//;

		$serialLFN = File::Spec->catfile( $root , $serialLFN );
	}

	$self->lfn( $serialLFN );
	$self->lastFullHash( shift @a );
	$self->fullHash( shift @a );


	print "Just deserialized: ";
	print $self->printDebug();
	print "\n";

	return $self;

}

sub printDebug
{
	my $self = shift;

	my $lfn = $self->lfn();
	my $lastFullHash = $self->lastFullHash();
	my $fullHash = $self->fullHash();

	print "A Ghost: lfn:[$lfn] lFH:[$lastFullHash] full:[$fullHash]";

}

sub serialize()
{
	my $self = shift;
	my %options = @_;

	my $lfn = $self->lfn();

	print "Serialize $self\n";

	if( $options{'pathMode'} eq 'basename' )
	{
			my( $fn, $dir ) = fileparse( $lfn );
			print "    Serialization has truncated $lfn -> $fn (pathMode)\n";
			$lfn = $fn;

	}

	# TODO: Add proper escapes (String::Escape has nice examples)

	my @s = ( $lfn, 
			  $self->lastFullHash(),
			  $self->fullHash()
			  );

	my $s = join ':', @s;

	return $s;
}

sub make($)
{
	my $class = shift;
	my $lfn = shift;

	my $self = $class->new();

	print "Making ghost for lfn=[$lfn]\n";
	$self->lfn( $lfn );
	return $self;
}

# Normally, the latest cached data is trusted, but
# this function can be set to take a out of data criteria in future TODO

sub getFullHash
{
	my $self = shift;

	if( defined $self->fullHash() )
	{
		return $self->fullHash();
	}
	else
	{
		return $self->getFullHashForceHitDisk();
	}
}


sub getFullHashForceHitDisk
{
	my $self = shift;
	my $lfn = $self->lfn();

	$self->lastFullHash( time() );

 	my $fullhash = main::getFullHashForceHitDisk( $lfn );

	$self->fullHash( $fullhash );

	return $fullhash;
}


###

main::main();
exit();



