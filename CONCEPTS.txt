
The basic object is a ghost. A ghost is a description of some object discovered "for real" in the filesystem somewhere. 

Things we track for ghosts:

FULLHASH - SHA of the bytestream (aka ghosthash)
FASTHAD - fast SHA of bytestream (empty if not present)
LASTMOD - last modified date from FS
DT_FULLHASH - last full verify
DT_FASTHASH - last fast verify
DT_DISC_OLD - oldest date of discovery
DT_DISC_NEW - newest date of discovery
LFN - one or more pathnames for ghosthash


my $ghost = makeOrFindGhost( LFN );

$GHOST->[FULLHASH];

writeGhostDescriptor( path, GHOST );

A .ghostdesc file is a list of the above entities of information.

The ghosttree is an abstraction around a collection of ghosts
there can be different implementations
the most basic one is just a hashing container that is as lazy as possible

$GhostTree = getAllGhostsUnderPath();

my @ghosts = GhostTree->ghostsForHash();


+++++++++++


# gfs snapshot .
# generates a snapshot file

# gfs condense /etc /var snap:barf.gs
# gfs condense snap:barf.gs snap:arf.gs snap:new.gs

# will reconstruct using known afns, keeps orphans
# gfs reconstruct --test snap:barf.gs foo/
# 150 files reconstructed, 4 not located (see gfsrun.3234.orphaned.txt for details)

# make symlinks rather than copy files
# gfs reconstruct --symlink 

# uses xxx and yyy as hash sources
# gfs reconstruct --test snap:barf.gs foo/ --source=xxx --source=yyyy

# verify all descriptors in /etc
# gfs verify /etc

# creates a GFS entity that can be pushed to
# gfs gfs create /etc gfs:foo.gfs

# gfs gfs push /etc gfs:foo.gfs
# makes sure that /etc can be reconstructed by gfs:foo.gfs

# gfs gfs add gfs:goo.
# a .gfs file can contain storage and 



++++++++++++++





now we have a bit of an issue
the FSE implementation is pretty tied to the descriptor logic
also, ghosts can be part of many different ghost stores
and there is no clean way for updated truth to be spontaneosly discovered and written back out to 
those files

maybe ghoststore is really just a good convienence method for a collection of ghosts
don't think of it as a first class object

maybe the FSE is really the management concept around a filesystem and its state
its handles the details of its "backing store".
we don't worry about Ghosts being in more than one GS, because FSE is really controlling the end-to-end behavior

fse->writeSnapshot()

$gs2 = fse->gs()->merge( fse2->gs() );

the GS of an FSE is only for files in its tree (although maybe we don't have to take this
as a super strict rule?)

i = fse->findAllDuplicates(); # starts stat scan, returns first match;
i->next();

fse->removeFile( $i );
fse->copyFile( $i , $destFSE, $xfn )

i = fse->findOverlap( fse2 ) -- returns a hit for everything in FSE that is matched in fse2
f = i->getNext

fse2->findDuplicateOfGhost( f );

the FSE syntax shpuld be implmeneted for real filesystes, remote filesystems and snapshots
